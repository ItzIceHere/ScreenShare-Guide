
<!DOCTYPE html>
<html lang="it">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SS GUIDE Remastered</title>
        <!-- Collega il foglio di stile esterno 'style.css' -->
        <link rel="stylesheet" href="style.css">
        <!-- Il blocco <style> che era qui è stato rimosso -->
    </head>
<body>

    <h2 class="section-title">An Introduction to Hack Checks (Screenshares) and Bypasses</h2>

    <p class="body-paragraph">
        This document aims to provide a clear and structured understanding of the practice known as hack checks or screenshares, particularly within gaming communities like Minecraft and FiveM.
        The focus here is on the procedural and positive aspects of ensuring fair play through these checks.
    </p>

    <h3 class="subsection-title">What is a Hack Check (Screenshare)?</h3>

    <p class="body-paragraph">
        A Hack Check, commonly referred to as a Screenshare, is a procedure utilized by server staff members to determine whether a player is using cheats or unauthorized advantages. It's a practice designed to uphold fair play within the game environment by verifying the legitimacy of a player's setup and actions.
    </p>

    <h3 class="subsection-title">The Goal: Demonstrating Cheat Usage</h3>

    <p class="body-paragraph">
        The fundamental purpose of a screenshare is to demonstrate—or rule out—the use of cheats by a player. How this demonstration is achieved and what constitutes sufficient proof can vary significantly depending on server rules.
    </p>

    <p class="body-paragraph">
        Possession vs. Execution: Some servers may ban players simply for having cheat files present on their system within a specific timeframe (ban for possession). In this case, the staffer's goal is to find traces of the cheat's existence. More commonly, servers require proof that a cheat was actively running and potentially interacting with the game (ban for execution).
    </p>

    <p class="body-paragraph">
        The Importance of Execution Context: When proving execution, precision is key. It's not enough to show a cheat program ran at some point. Staffers often need to demonstrate that the cheat was executed during the relevant gameplay or boot session. This involves comparing the execution timestamp of the cheat (<code class="file-extension">.exe</code>, <code class="file-extension">.jar</code>, <code class="file-extension">.dll</code>, etc.) with the start time of the game process or the logon time in the PC (e.g., Minecraft's javaw.exe process). This specific timeframe is often referred to asgame instance or boot instance. Bans based on execution outside this relevant instance may be considered imprecise or lacking sufficient proof, depending entirely on the server's specific ruleset.
    </p>

    <h3 class="subsection-title">The Role of Tools in Screenshares</h3>

    <p class="body-paragraph">
        Screenshares are not performed through guesswork; they rely on specific software tools. These generally fall into three categories:
    </p>
    <ul>
        <li><p class="list-item">Screen Sharing Tools: Programs like AnyDesk or TeamViewer allow the staffer to view and, crucially, interact with the player's computer (with permission). Discord is sometimes used but is generally less effective as it typically lacks remote control capabilities.</p></li>
        <li><p class="list-item">Manual Cheat Detection Tools: These are programs and command-line utilities (e.g., Process Hacker/System Informer, registry viewers, filesystem analyzers) that allow staffers to examine various system artifacts (like running processes, memory strings, file timestamps, system logs) for signs of cheats. These require interpretation and analysis by the staffer.</p></li>
        <li><p class="list-item">Automatic Cheat Detection Tools: Programs like Echo, Ocean, Storm, etc., automatically scan system artifacts and compare findings against their internal databases and detection methods. While they can speed up the process, no one should rely solely on the use of these tools. Understanding the manual methods is crucial to correctly interpret the results (or lack thereof) from automatic tools and to avoid missing cheats they might not detect or misinterpreting their flags.</p></li>
    </ul>

    <h3 class="subsection-title">The Staffer's Perspective and the Learning Process</h3>

    <ul>
        <li><p class="list-item">Goal: The primary objective is to eliminate cheaters and maintain a fair gaming environment, not to build personal reputation or "farm bans."</p></li>
        <li><p class="list-item">Dealing with Failure: It's acknowledged that staffers might sometimes fail to find evidence even when cheats were used. These instances should be treated as constructive learning experiences. Analyzing what went wrong helps the staffer improve their techniques and understanding for future checks.</p></li>
        <li><p class="list-item">Integrity: Staffers should not issue bans out of fear of being bypassed, nor should they make assumptions. Bans must be based on concrete evidence found according to established server rules. Honesty – with oneself, the player, and the community – is paramount.</p></li>
    </ul>

    <hr>

    <h2 class="section-title">First Section:</h2>

    <h3 class="subsection-title">Red Lotus Principles for Ethical and Effective ScreenSharing</h3>
    <p class="body-paragraph">
        The Red Lotus Unity establishes specific governing principles to ensure ScreenShares are conducted ethically and effectively. These principles emphasize:
    </p>
    <ul>
        <li><p class="list-item">Player Safety Over Accuracy: The security and safety of players are deemed more important than the accuracy or speed of the ScreenShare process itself, regardless of whether cheats are detected.</p></li>
        <li><p class="list-item">Data Security Paramount: The protection of player data is imperative and takes precedence over any potential advantage for the server or ScreenSharing team.</p></li>
        <li><p class="list-item">Upholding Fair Play Standards: Red Lotus condemns any action to dismantle or weaken institutions or regulations that ensure fair play and privacy during ScreenShares.</p></li>
        <li><p class="list-item">Verified ScreenSharer Expertise: The experience and specialization of individuals conducting ScreenShares (referred to as "ScreenSharers," "PC Checkers," or "Account Reviewers") must be rigorously tested and approved by designated team leadership (e.g., SS Management, Administration).</p></li>
        <li><p class="list-item">Adherence to the Charter: Any server or community implementing or referencing Red Lotus guidelines is responsible for creating a system that fully aligns with the Red Lotus Charter and its foundational principles.</p></li>
    </ul>

    <h3 class="subsection-title">Security and Privacy in ScreenShares (Red Lotus Principles)</h3>
    <p class="body-paragraph">
        Security and privacy are core tenets of the Red Lotus approach to ScreenSharing:
    </p>
    <ul>
        <li><p class="list-item">Player Well-being First: As stated in the core principles, player security and safety are the highest priority during any ScreenShare.</p></li>
        <li><p class="list-item">Imperative Data Protection: Ensuring the confidentiality and integrity of player data is non-negotiable.</p></li>
        <li><p class="list-item">Protection of Privacy Measures: Regulations and practices designed to protect player privacy must be strictly maintained and respected.</p></li>
        <li><p class="list-item">Video Recording for Integrity: Mandatory video recording serves multiple security and privacy purposes, including ensuring player safety, allowing evidence review by management, and preventing tampering or framing by malicious actors. (See Protocol section for details).</p></li>
        <li><p class="list-item">Evidence Sharing: Suspects have the right to request access to the evidence gathered against them, provided the request is reasonable and judged appropriately based on context and behaviour.</p></li>
    </ul>

    <h3 class="subsection-title">Requirements for ScreenSharers (Red Lotus Principles)</h3>
    <p class="body-paragraph">
        Red Lotus outlines specific prerequisites for individuals performing ScreenShares:
    </p>
    <ul>
        <li><p class="list-item">Minimum Age: ScreenSharers must be at least 16 years old.</p></li>
        <li><p class="list-item">Minimum Experience: A minimum of 4 months of experience purely in ScreenSharing is required. This ensures a baseline understanding of procedures and principles.</p></li>
        <li><p class="list-item">Verified Skills: Experience must be actively verified by server/team management, typically through practical tests involving manual bypass techniques (Anti-ScreenShare tests).</p></li>
        <li><p class="list-item">Country Information: A ScreenSharer's country should be noted solely for addressing potential legal complexities. IP addresses, specific geolocations (State/City/Urban area), MUST NOT be requested or stored.</p></li>
    </ul>

    <h3 class="subsection-title">ScreenSharing Protocols (Video Recording - Red Lotus Principles)</h3>
    <p class="body-paragraph">
        Red Lotus mandates strict protocols regarding the documentation of ScreenShares:
    </p>
    <ul>
        <li><p class="list-item">Mandatory Video Recording: It is compulsory for ScreenSharers to record the entirety of every ScreenShare conducted. This applies regardless of the ScreenSharer's device capabilities (i.e., "low-end PC" is not a valid excuse).</p></li>
        <li><p class="list-item">Purposes of Recording:</p>
            <ul>
                <li><p class="list-item">Player Safety: Ensures a record exists in case of disputes or misconduct.</p></li>
                <li><p class="list-item">Evidence Review: Allows management to review the evidence collected.</p></li>
                <li><p class="list-item">Accuracy & Truthfulness: Verifies the integrity of the ScreenShare process and prevents framing.</p></li>
                <li><p class="list-item">Legal Compliance: Serves as a record compliant with data security and privacy standards.</p></li>
                <li><p class="list-item">Skill Verification: Helps assess the ScreenSharer's competence and adherence to procedures.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Consequences of Non-Compliance: Failure to record may result in penalties such as demotion, suspension, or skill re-evaluation.</p></li>
        <li><p class="list-item">Invalid Bans: Bans issued based on a ScreenShare without corresponding video evidence MUST be overturned immediately.</p></li>
        <li><p class="list-item">Screenshots Exception (Limited): Screenshots may be acceptable only if the ScreenSharer has a proven track record of respecting player privacy and security. However, if any allegations arise regarding the ScreenShare, video evidence requirements still apply.</p></li>
    </ul>

    <h3 class="subsection-title">Anti-Corruption Measures (Red Lotus Principles)</h3>
    <p class="body-paragraph">
        To maintain integrity and fairness, Red Lotus implements anti-corruption measures:
    </p>
    <ul>
        <li><p class="list-item">Purpose: These measures aim to prevent false punishments, bribery, evidence planting, and any other actions compromising the genuineness and accuracy of ScreenShares.</p></li>
        <li><p class="list-item">No Bribery: Any form of bribery is strictly disallowed. Any benefits received from non-standard sources must be transparently managed and typically split among the team, overseen by Leaders, Managers, or Owners.</p></li>
        <li><p class="list-item">Evidence Scrutiny: If collected evidence is insufficient or raises questions, the ScreenSharer's explanation should not be automatically accepted without further scrutiny by management or leadership.</p></li>
        <li><p class="list-item">Right to Review Evidence: Suspects should be allowed to review the evidence gathered against them upon submitting a reasonable request. The reasonability is judged based on the suspect's behaviour and the stated purpose of the request.</p></li>
    </ul>

    <hr>

    <h2 class="section-title">Section 2: Windows Fundamentals</h2>

    <h3 class="subsection-title">File Systems: The Foundation</h3>

    <h4 class="subsection-title">File System (Definition, Types: NTFS, FAT32, etc.)</h4>
    <p class="body-paragraph">
        Fundamentally, a file system is the hierarchical structure that enables the operating system, and by extension the user, to organize data on storage media like hard drives or USB sticks. It manages how data is stored, accessed, and retrieved, defining the structure of folders (directories), file permissions, naming conventions, metadata, and the overall organization of the storage volume. Different operating systems support various file systems, each with its own features and limitations. Some common examples include:
    </p>
    <ul>
        <li><p class="list-item">NTFS (New Technology File System): The standard, modern file system for Windows operating systems, offering features like journaling, robust permissions, encryption, compression, and support for large files and volumes. This guide primarily focuses on NTFS due to its prevalence in Windows environments relevant to ScreenShares.</p></li>
        <li><p class="list-item">FAT32/FAT16 (File Allocation Table): Older, simpler file systems often used for compatibility, especially on removable media like USB drives. They lack features like journaling and robust permissions found in NTFS. FAT32 does not support journaling, which is a significant difference noted in contexts like analyzing USB drives.</p></li>
        <li><p class="list-item">exFAT (Extended File Allocation Table): An evolution of FAT32, designed for large flash drives, offering support for larger files and volumes than FAT32 while maintaining broader compatibility than NTFS across different operating systems.</p></li>
        <li><p class="list-item">Other examples: ext4/ext3/ext2 (Linux), APFS/Mac FS (macOS), ReFS (Windows Server).</p></li>
    </ul>

    <h4 class="subsection-title">Journaling (Definition, Purpose)</h4>
    <p class="body-paragraph">
        Journaling is a crucial feature of modern file systems like NTFS (and ext4, APFS, etc.) designed to enhance reliability and data integrity, especially after system crashes or unexpected shutdowns. Instead of directly modifying the disk structure, a journaling file system first records the intended changes in a dedicated log file, known as the journal. Only after the changes are safely recorded in the journal does the file system apply them to the main disk structure.
    </p>
    <p class="body-paragraph">
        The primary purpose is crash recovery. If the system crashes mid-operation, upon restart, the file system can read the journal to see which operations were pending or incomplete. It can then quickly replay or roll back these changes to bring the file system back to a consistent state without needing a time-consuming full disk check (like chkdsk on older non-journaled systems). This significantly speeds up system startup after failures and reduces the risk of data corruption. NTFS utilizes specific components like <code class="path-example">$USNJrnl</code> and <code class="path-example">$LogFile</code> for its journaling and logging activities.
    </p>

    <h3 class="subsection-title">Fundamental Timestamps</h3>

    <h4 class="subsection-title">MACB Timestamps (Modified, Access, Changed, Birth) - Definition and Significance</h4>
    <p class="body-paragraph">
        Files within NTFS possess several timestamps that record critical information about their lifecycle. The most fundamental set is often referred to by the acronym MACB:
    </p>
    <ul>
        <li><p class="list-item">(M) Modified / Modificato: This timestamp indicates the last time the content of the file was actually changed. Saving changes to a document, editing an image, or altering the code within an executable would update this timestamp.</p></li>
        <li><p class="list-item">(A) Access / Accesso: This timestamp records the last time the file was accessed – meaning opened, read, or executed. However, during ScreenShares, this timestamp is often considered unreliable for proving direct user interaction. Many background processes, system services (especially for compatibility), antivirus scans, and indexing services can trigger an access time update without the user actively opening the file. Relying solely on the Access time can therefore lead to potential false positives ('false flag') when trying to demonstrate file execution by the user.</p></li>
        <li><p class="list-item">(C) Changed / Cambiato: This timestamp reflects the last time the file's metadata or its entry within the Master File Table (<code class="path-example">$MFT</code>) was changed. This includes modifications to file permissions, attributes (like Read-Only or Hidden), filename changes, or moving the file between directories on the same volume. Importantly, changing the file's content (which updates the Modified time) does not necessarily update the Changed time unless metadata also changes.</p></li>
        <li><p class="list-item">(B) Birth / Creazione: This timestamp marks the moment the file was created on the specific file system volume (disk). Copying a file to a new location assigns it a new Birth time at that destination.</p></li>
    </ul>
    <p class="body-paragraph">
        Understanding these timestamps, especially the unreliability of the Access time in specific ScreenShare contexts, is fundamental for accurate analysis.
    </p>

    <h3 class="subsection-title">Key NTFS Components</h3>
    <p class="body-paragraph">
        NTFS utilizes several special system files (metafiles) and structures, often hidden and inaccessible through standard means, to manage the volume. Knowledge of these is vital for forensic analysis and understanding ScreenShare artifacts.
    </p>

    <h4 class="subsection-title">Master File Table ($MFT) - The File Catalog</h4>
    <p class="body-paragraph">
        The Master File Table (<code class="path-example">$MFT</code>) is the core database of an NTFS volume. It is a special file that contains at least one entry (record) for every file and directory on the volume. Each MFT record stores crucial metadata about the corresponding file or directory, including its name, size, attributes (like Hidden, Read-Only, System), security permissions, and the MACB timestamps. It also contains pointers indicating where the actual file data is located on the disk (or stores small files directly within the MFT record itself). Parsing the <code class="path-example">$MFT</code> provides a comprehensive catalog of all files present (and sometimes recently deleted) on the volume, making it a cornerstone artifact for analysis. Changes to a file's MFT entry update the '(C) Changed' timestamp.
    </p>

    <h4 class="subsection-title">The Journal ($USNJrnl, Stream $J, Stream $Max) - The Change Log</h4>
    <p class="body-paragraph">
        As part of its journaling capability, NTFS uses the <code class="path-example">$USNJrnl</code> metafile, typically located in the hidden <code class="path-example">C:\$Extend</code> directory (usually inaccessible via Windows Explorer). This file acts as a detailed log, often referred to simply as "the journal," recording changes made to files and directories on the volume. It tracks a wide array of activities, including:
    </p>
    <ul>
        <li><p class="list-item">File/directory creation, deletion, renaming.</p></li>
        <li><p class="list-item">Changes to file data (overwrites, extensions, truncations).</p></li>
        <li><p class="list-item">Changes to file attributes and security settings.</p></li>
        <li><p class="list-item">Stream modifications (including Alternate Data Streams).</p></li>
    </ul>
    <p class="body-paragraph">
        The <code class="path-example">$USNJrnl</code> file itself often appears empty, but its crucial information resides in two Alternate Data Streams (ADS) associated with it:
    </p>
    <ul>
        <li><p class="list-item"><code class="path-example">$Max</code>: Contains metadata about the journal itself, such as its maximum size and ID.</p></li>
        <li><p class="list-item"><code class="path-example">$J</code>: Contains the actual log entries, known as USN Records.</p></li>
    </ul>
    <p class="body-paragraph">
        USN Records (Update Sequence Number Records): These are the individual entries within the <code class="path-example">$J</code> stream. Each record details a specific change event, including the file affected, the type of change (e.g., FILE_CREATE, FILE_DELETE, RENAME_NEW_NAME, DATA_OVERWRITE, BASIC_INFO_CHANGE), timestamps, and unique identifiers. Utilities like Windows' built-in <code class="code-block">fsutil usn readjournal c:</code> or specialized forensic tools (like MFTECmd, JournalTrace, Echo Journal Viewer) are used to parse and interpret these records, providing a chronological history of file system activity.
    </p>

    <h4 class="subsection-title">$LogFile (Metadata Log) - Specific Log for Metadata Changes</h4>
    <p class="body-paragraph">
        Similar in concept but distinct in function from the <code class="path-example">$USNJrnl</code> is the <code class="path-example">$LogFile</code>. While <code class="path-example">$USNJrnl</code> tracks a broad range of file system events via USN Records, <code class="path-example">$LogFile</code> specifically logs transactional changes made to file system metadata. This includes modifications to attributes, timestamps (MACB), MFT records, and other structural information before they are permanently written. It plays a key role in NTFS's recoverability. For forensic purposes, <code class="path-example">$LogFile</code> can be extremely valuable for reconstructing metadata changes, potentially revealing timestomping or attribute manipulations, although it is notably difficult to parse. Specialized tools like "NTFS Log Parser" are required to interpret its contents effectively.
    </p>

    <h4 class="subsection-title">Alternate Data Streams (ADS) - Hidden Data Streams</h4>
    <p class="body-paragraph">
        Alternate Data Streams (ADS) are a lesser-known feature of NTFS that allows more than one data stream to be associated with a single file name. Every file has a primary, unnamed data stream (<code class="path-example">:$DATA</code>) where its main content resides (e.g., the text in a <code class="file-extension">.txt</code> file, the image data in a <code class="file-extension">.jpg</code>). However, NTFS allows additional, named streams to be attached to the same file.
    </p>
    <p class="body-paragraph">
        This capability can be abused to hide data. For example, malicious code, tools, or sensitive information can be stored in an ADS attached to an innocuous file (like notepad.exe or a simple <code class="file-extension">.txt</code> file). Standard tools like Windows Explorer do not display the existence or size of these alternate streams, making them effectively hidden from casual view. Specific commands (like <code class="code-block">dir /r</code>) or dedicated tools (like AlternateStreamView, Streams) are needed to detect and examine ADS.
    </p>

    <h4 class="subsection-title">File Attributes (Read-Only, Hidden, etc.) - Manipulable Properties</h4>
    <p class="body-paragraph">
        NTFS files possess various attributes that control their behavior and visibility. Common attributes include:
    </p>
    <ul>
        <li><p class="list-item">Read-Only: Prevents the file's content from being modified or the file from being deleted easily.</p></li>
        <li><p class="list-item">Hidden: Hides the file from view in default directory listings (like in File Explorer or basic <code class="code-block">dir</code> commands). Requires changing view settings or using specific commands (like <code class="code-block">dir /ah</code>) to see.</p></li>
        <li><p class="list-item">System: Marks a file as critical for the operating system; these are usually hidden as well.</p></li>
        <li><p class="list-item">Archive: Used by backup software to track which files have changed.</p></li>
    </ul>
    <p class="body-paragraph">
        These attributes can be viewed and modified using file properties in Windows Explorer, command-line tools (<code class="code-block">attrib</code>, <code class="code-block">cacls</code>, <code class="code-block">icacls</code>), or programmatically. In the context of ScreenShares, attributes can be manipulated to hide malicious files (Hidden attribute) or to prevent detection artifacts from being updated (e.g., setting a Prefetch file to Read-Only to stop its execution timestamp from changing). Such manipulations are often logged in the <code class="path-example">$USNJrnl</code> under the BASIC_INFO_CHANGE reason code.
    </p>

    <hr>

    <h2 class="section-title">Common Windows Artifacts and Their Basic Analysis</h2>

    <p class="body-paragraph">
        This section delves into common Windows artifacts that provide valuable insights into system activity during a ScreenShare. Understanding these artifacts is fundamental for identifying traces of execution, recent user actions, and potential manipulation attempts.
    </p>

    <h3 class="subsection-title">Execution Traces and Recent Activity</h3>

    <p class="body-paragraph">
        Identifying when and how applications were executed or files were accessed is crucial. Several Windows artifacts store this information.
    </p>

    <h4 class="subsection-title">Prefetch (<code class="path-example">C:\Windows\Prefetch</code>)</h4>
    <ul>
        <li><p class="list-item">Purpose: Originally designed to speed up application loading by storing data about frequently used programs. Forensically, it serves as a primary indicator of program execution.</p></li>
        <li><p class="list-item">Location: <code class="path-example">C:\Windows\Prefetch</code> (Access via Win+R -> <code class="path-example">prefetch</code>)</p></li>
        <li><p class="list-item">File Format: Contains <code class="file-extension">.pf</code> files named <code class="path-example">EXECUTABLENAME.EXE-HASH.pf</code>. The hash changes if the file's path changes.</p></li>
        <li><p class="list-item">Data Stored:</p>
            <ul>
                <li><p class="list-item">Executable Name</p></li>
                <li><p class="list-item">Executable Path Hash</p></li>
                <li><p class="list-item">Run Count (total executions)</p></li>
                <li><p class="list-item">Last Execution Timestamp (Note: The Date Modified timestamp of the <code class="file-extension">.pf</code> file itself reflects the last execution time)</p></li>
                <li><p class="list-item">Up to 8 previous execution timestamps</p></li>
                <li><p class="list-item">Volume (Drive) information (Name, Serial Number, Creation Date)</p></li>
                <li><p class="list-item">Directories and Files accessed by the executable during its initial startup phase.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Analysis Tools:</p>
            <ul>
                <li><p class="list-item">WinPrefetchView (Nirsoft): GUI tool for easy parsing and viewing of <code class="file-extension">.pf</code> file contents, including loaded files/DLLs within the prefetch data itself (bottom pane).</p></li>
                <li><p class="list-item">PECmd (Eric Zimmerman): Command-line tool for in-depth analysis, extracting all available metadata, useful when WinPrefetchView fails or more detail is needed.</p></li>
                <li><p class="list-item">LastActivityView (Nirsoft): Also utilizes Prefetch data alongside other sources.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Dependencies and Bypasses:</p>
            <ul>
                <li><p class="list-item">Service: Relies on the SysMain (formerly Superfetch) service. Check its status using <code class="code-block">sc query sysmain</code>. A stopped service is suspicious.</p></li>
                <li><p class="list-item">Registry Key: The status (enabled/disabled) is controlled by <code class="registry-key">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters\EnablePrefetcher</code>. A value of 0 indicates it's disabled.</p></li>
                <li><p class="list-item">Permissions Bypass (<code class="code-block">cacls</code>): Modifying permissions on the Prefetch folder to prevent writing can bypass logging. This action itself may be logged in the USN Journal.</p></li>
                <li><p class="list-item">Hiding Files: Individual <code class="file-extension">.pf</code> files can be hidden. Use <code class="code-block">dir /ah C:\Windows\Prefetch</code> in an administrative Command Prompt to view hidden files.</p></li>
                <li><p class="list-item">Renamed/Non-Executable Files: Prefetch generally logs <code class="file-extension">.exe</code> executions. However, executing <code class="file-extension">.jar</code> files often generates <code class="path-example">java.exe</code> or <code class="path-example">javaw.exe</code> prefetch entries, which can be analyzed for the specific <code class="file-extension">.jar</code> file path. Similarly, DLL injections might create entries for <code class="path-example">rundll32.exe</code> or <code class="path-example">regsvr32.exe</code>. Executing a renamed file (e.g., <code class="file-extension">.txt</code> containing executable code run via specific methods) might still generate a <code class="file-extension">.pf</code> file under the process that launched it, or potentially under the fake name if run through certain loaders, which is highly suspicious.</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">Temporary Files (<code class="path-example">%temp%</code>)</h4>
    <ul>
        <li><p class="list-item">Purpose: Stores temporary data created by Windows and applications during operation.</p></li>
        <li><p class="list-item">Location: <code class="path-example">C:\Users\{username}\AppData\Local\Temp</code> (Access via Win+R -> <code class="path-example">%temp%</code>)</p></li>
        <li><p class="list-item">Key Artifacts:</p>
            <ul>
                <li><p class="list-item">JnativeHook: Some Java-based autoclickers utilize the JnativeHook library and may drop a <code class="path-example">JnativeHook-{random numbers}.dll</code> file in this directory upon execution. The file's creation/modification time indicates execution time.</p></li>
            </ul>
        </li>
        <div class="note-box"><p class="body-paragraph">Note: This is not entirely reliable. Not all Java cheats use this library, and the file can be easily deleted (check USN Journal for deletions).</p></div>
        <ul>
            <li><p class="list-item">Unpacked Archives: Files run directly from within compressed archives (e.g., <code class="file-extension">.zip</code>, <code class="file-extension">.rar</code>) might be temporarily extracted here. Look for folders like <code class="path-example">Rar$</code> or <code class="path-example">7z$</code> followed by temporary names, potentially containing the executed file. The modification times of these temporary files/folders can indicate recent activity.</p></li>
        </ul>
    </ul>

    <h4 class="subsection-title">Recent Items (<code class="path-example">shell:recent</code>)</h4>
    <ul>
        <li><p class="list-item">Purpose: Stores shortcuts (<code class="file-extension">.lnk</code> files) pointing to files and folders that the user has recently opened or accessed. Its functionality depends on Windows settings.</p></li>
        <li><p class="list-item">Location: <code class="path-example">C:\Users\{username}\AppData\Roaming\Microsoft\Windows\Recent</code> (Access via Win+R -> <code class="path-example">shell:recent</code>)</p></li>
        <li><p class="list-item">File Format: Contains <code class="file-extension">.lnk</code> shortcut files.</p></li>
        <li><p class="list-item">Forensic Value:</p>
            <ul>
                <li><p class="list-item">Provides context about user activity and interaction with specific files or locations.</p></li>
                <li><p class="list-item">While finding direct cheat evidence (like <code class="file-extension">.dll</code> files listed here) is less common and considered somewhat "deprecated," it can corroborate findings from other artifacts.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Related Artifacts: Closely linked to Jump Lists (recently accessed files per application, visible in the taskbar/start menu) and the RecentDocs registry keys (<code class="registry-key">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs</code>). Clearing the RecentDocs registry key often clears the <code class="path-example">shell:recent</code> folder. Jump List data, however, might persist separately (<code class="path-example">%AppData%\Microsoft\Windows\Recent\AutomaticDestinations</code> and <code class="path-example">CustomDestinations</code>).</p></li>
    </ul>

    <h4 class="subsection-title">Recycle Bin (<code class="path-example">C:\$Recycle.bin</code>)</h4>
    <ul>
        <li><p class="list-item">Purpose: Stores files deleted by the user through standard deletion methods (not Shift+Delete).</p></li>
        <li><p class="list-item">Location: <code class="path-example">C:\$Recycle.bin</code> (Hidden system folder)</p></li>
        <li><p class="list-item">Accessing: Requires enabling "Show hidden files, folders, and drives" and disabling "Hide protected operating system files" in File Explorer options.</p></li>
        <li><p class="list-item">Forensic Analysis:</p>
            <ul>
                <li><p class="list-item">The key is analyzing the metadata within this folder. Each deleted file has two corresponding hidden files:</p>
                    <ul>
                        <li><p class="list-item"><code class="path-example">$I{unique_ID}.{original_extension}</code>: Contains metadata like the original path and deletion timestamp.</p></li>
                        <li><p class="list-item"><code class="path-example">$R{unique_ID}.{original_extension}</code>: Contains the actual file data.</p></li>
                    </ul>
                </li>
                <li><p class="list-item">The Date Modified/Created timestamp of the <code class="path-example">$I...</code> file indicates when the file was deleted.</p></li>
                <li><p class="list-item">Checking these timestamps, especially for files deleted shortly before or during a ScreenShare, is critical.</p></li>
                <li><p class="list-item">The overall modification date of the <code class="path-example">$Recycle.bin</code> folder itself (or its subfolders named by user SIDs) can indicate the last time any interaction occurred (deletion, restoration, emptying).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Bypasses:</p>
            <ul>
                <li><p class="list-item">Shift+Delete: Permanently deletes the file, bypassing the Recycle Bin. This action is logged elsewhere (e.g., USN Journal).</p></li>
                <li><p class="list-item">FAT32/exFAT: Drives formatted with these file systems do not typically have a Recycle Bin structure like NTFS.</p></li>
            </ul>
        </li>
    </ul>

    <h3 class="subsection-title">Other Notable Folders/Locations</h3>

    <p class="body-paragraph">
        Beyond the main artifacts above, numerous other specific locations can hold valuable evidence:
    </p>
    <ul>
        <li><p class="list-item">Task Scheduler: <code class="path-example">C:\Windows\System32\Tasks</code> (Stores scheduled task definitions, often used for persistence or bypasses).</p></li>
        <li><p class="list-item">Program Compatibility Assistant (PCA): <code class="path-example">C:\Windows\appcompat\pca</code> (Stores <code class="path-example">Amcache.hve</code> and <code class="path-example">RecentFileCache.bcf</code> which track application executions, especially useful on older systems or as supplementary evidence).</p></li>
        <li><p class="list-item">PowerShell History: <code class="path-example">%AppData%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt</code> (Logs commands typed in PowerShell sessions).</p></li>
        <li><p class="list-item">User Assist: Registry keys tracking GUI program executions.</p></li>
    </ul>

    <h3 class="subsection-title">Windows Registry: Introduction</h3>
    <ul>
        <li><p class="list-item">Purpose: The Windows Registry is a central, hierarchical database that stores low-level settings and configuration options for the operating system and installed applications. It's essential for Windows functionality.</p></li>
        <li><p class="list-item">Access: The primary tool for viewing and editing the Registry is <code class="path-example">regedit.exe</code> (Run Win+R -> <code class="code-block">regedit</code>). Other specialized tools like Registry Explorer (Eric Zimmerman) offer more advanced forensic features.</p></li>
        <li><p class="list-item">Forensic Importance: The Registry is a goldmine for forensic investigators, containing information about:</p>
            <ul>
                <li><p class="list-item">System configuration and hardware.</p></li>
                <li><p class="list-item">Installed software and execution history (e.g., MRU lists, UserAssist).</p></li>
                <li><p class="list-item">User account information and activity (e.g., last login).</p></li>
                <li><p class="list-item">USB device connection history (USBSTOR).</p></li>
                <li><p class="list-item">Network settings and history.</p></li>
                <li><p class="list-item">Malware persistence mechanisms (e.g., Run keys, scheduled tasks registry entries).</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">Registry Structure: Hives, Keys, and Values</h4>
    <ul>
        <li><p class="list-item">Hives: The highest level of the Registry structure, analogous to root folders. Key hives include:</p>
            <ul>
                <li><p class="list-item">HKEY_LOCAL_MACHINE (HKLM): System-wide hardware and software settings. Physically stored in files within <code class="path-example">C:\Windows\System32\config</code> (e.g., SAM, SECURITY, SOFTWARE, SYSTEM).</p></li>
                <li><p class="list-item">HKEY_CURRENT_USER (HKCU): Settings specific to the currently logged-in user. Physically stored in the user's profile (<code class="path-example">C:\Users\{username}\NTUSER.DAT</code>).</p></li>
                <li><p class="list-item">Other root keys like HKEY_CLASSES_ROOT (HKCR), HKEY_USERS (HKU), and HKEY_CURRENT_CONFIG (HKCC) are largely derived from HKLM and HKCU.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Keys/Subkeys: Containers within hives, organized like folders and subfolders, structuring the settings logically.</p></li>
        <li><p class="list-item">Values: The actual data entries within keys. Each value has a name, a data type, and the data itself.</p></li>
    </ul>

    <h4 class="subsection-title">Registry Value Types (Brief Overview)</h4>
    <p class="body-paragraph">
        Registry values store data in various formats. Common types encountered in basic analysis include:
    </p>
    <ul>
        <li><p class="list-item">REG_SZ: A standard fixed-length text string (e.g., file paths, application names).</p></li>
        <li><p class="list-item">REG_EXPAND_SZ: An expandable text string that can contain environment variables (e.g., <code class="path-example">%SystemRoot%\system32</code>).</p></li>
        <li><p class="list-item">REG_BINARY: Raw binary data.</p></li>
        <li><p class="list-item">REG_DWORD: A 32-bit number (often used for boolean flags [0 or 1] or numerical settings).</p></li>
        <li><p class="list-item">REG_QWORD: A 64-bit number.</p></li>
        <li><p class="list-item">REG_MULTI_SZ: Allows multiple text strings to be stored in a single value entry, separated by null characters.</p></li>
    </ul>

    <h3 class="subsection-title">Windows Event Logs: Introduction</h3>
    <ul>
        <li><p class="list-item">Purpose: Windows Event Logs are records of significant events occurring on the system, generated by the OS, services, and applications. They are crucial for troubleshooting, security auditing, and forensic analysis.</p></li>
        <li><p class="list-item">Forensic Value: Event Logs provide chronological records of activities such as:</p>
            <ul>
                <li><p class="list-item">User logins/logoffs (Success and Failure).</p></li>
                <li><p class="list-item">System startup and shutdown.</p></li>
                <li><p class="list-item">Application crashes and errors.</p></li>
                <li><p class="list-item">Security policy changes.</p></li>
                <li><p class="list-item">Service start/stop events.</p></li>
                <li><p class="list-item">File/Resource access attempts (if auditing is enabled).</p></li>
                <li><p class="list-item">Clearing of the event logs themselves (a highly suspicious event).</p></li>
                <li><p class="list-item">Specific bypass technique artifacts (e.g., time changes, USN Journal deletion).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Location: Logs are typically stored in <code class="path-example">%SystemRoot%\System32\Winevt\Logs\</code> (usually <code class="path-example">C:\Windows\System32\Winevt\Logs\</code>).</p></li>
    </ul>

    <h4 class="subsection-title">Event Log Structure (<code class="file-extension">.evtx</code> Files)</h4>
    <ul>
        <li><p class="list-item">Format: Event logs are stored in a proprietary binary format with the <code class="file-extension">.evtx</code> extension. Each <code class="file-extension">.evtx</code> file usually corresponds to a specific log channel.</p></li>
        <li><p class="list-item">Channels: Windows organizes events into different logs (channels) based on their source or type, such as:</p>
            <ul>
                <li><p class="list-item">Application: Events logged by applications.</p></li>
                <li><p class="list-item">Security: Security-related events like logins, resource access (requires auditing configuration).</p></li>
                <li><p class="list-item">System: Events logged by Windows system components (e.g., service start/stop, driver issues).</p></li>
                <li><p class="list-item">Setup: Events related to application setup.</p></li>
                <li><p class="list-item">ForwardedEvents: Events forwarded from other computers.</p></li>
                <li><p class="list-item">Numerous application/service-specific logs under "Applications and Services Logs".</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">The EventLog Service</h4>
    <ul>
        <li><p class="list-item">Dependency: The Windows Event Log service (eventlog) is essential for the logging system to function. If this service is stopped, no new events will be recorded, and tools like Event Viewer will not work.</p></li>
        <li><p class="list-item">Checking Status: Use the command <code class="code-block">sc query eventlog</code> in an administrative Command Prompt. If the service state is not RUNNING, it is highly suspicious and indicative of tampering.</p></li>
    </ul>

    <h4 class="subsection-title">Event Viewer (<code class="path-example">eventvwr.msc</code>)</h4>
    <ul>
        <li><p class="list-item">Purpose: The built-in Windows GUI tool for browsing, searching, and filtering event logs.</p></li>
        <li><p class="list-item">Access: Run Win+R -> <code class="code-block">eventvwr</code> or <code class="code-block">eventvwr.msc</code>.</p></li>
        <li><p class="list-item">Basic Use: Allows navigation through different log channels (Application, Security, System, etc.). Key features include filtering by Event ID, time range, keywords, user, or severity level (Information, Warning, Error, Critical).</p></li>
        <div class="attention-box"><p class="body-paragraph">Caution: While powerful, effectively using Event Viewer requires knowing which specific Event IDs or log sources are relevant to the investigation at hand. Simply browsing without a target can be time-consuming and unproductive. Specific Event IDs related to common bypass techniques (e.g., 4616 for time change, 1102 for log clearing, 3079 for USN Journal deletion) are crucial for targeted analysis but are beyond the scope of this basic introduction.</p></div>
    </ul>

    <hr>

    <h2 class="section-title">Section 4: Specific Context: Minecraft</h2>

    <p class="body-paragraph">
        This section delves into the specifics of conducting ScreenShares within the Minecraft environment, focusing on its Java-based architecture, common cheat types, and specialized analysis techniques.
    </p>

    <h3 class="subsection-title">Minecraft and Java</h3>

    <p class="body-paragraph">
        Understanding Minecraft's technical foundation is crucial for effective cheat detection during a ScreenShare.
    </p>

    <h4 class="subsection-title">Minecraft Architecture (Java, JVM)</h4>
    <p class="body-paragraph">
        Minecraft is developed in Java, which has significant implications for how the game runs and how cheats operate.
    </p>
    <ul>
        <li><p class="list-item">Java Virtual Machine (JVM): Because it's written in Java, Minecraft does not run as a typical standalone executable (e.g., <code class="path-example">minecraft.exe</code>). Instead, it operates within a Java Virtual Machine process. This process usually appears as <code class="path-example">java.exe</code> or <code class="path-example">javaw.exe</code> in the system's task list.</p></li>
        <li><p class="list-item">Process Identification: When analyzing processes during a ScreenShare, the target process for Minecraft-related activity will be an instance of <code class="path-example">java.exe</code> or <code class="path-example">javaw.exe</code>, not a uniquely named Minecraft process.</p></li>
    </ul>

    <h4 class="subsection-title">Launchers (Official, Custom: Lunar, Badlion, etc.)</h4>
    <p class="body-paragraph">
        Minecraft requires a launcher to initiate the game. Launchers manage game versions, user profiles, and the command-line arguments needed to start the JVM with Minecraft.
    </p>
    <ul>
        <li><p class="list-item">Function: Launchers execute the necessary <code class="code-block">java -jar</code> command, often with numerous complex arguments, to start the specific Minecraft version selected by the user.</p></li>
        <li><p class="list-item">Variety: Players may use the official Minecraft launcher or various third-party launchers (e.g., Lunar Client, Badlion Client, Feather Client, MultiMC). These custom launchers often provide performance enhancements, integrated mods, or unique features, but also serve as potential vectors for cheats.</p></li>
        <li><p class="list-item">Logs & Settings: Each launcher maintains its own logs and configuration settings, which can sometimes contain relevant information during a ScreenShare. Custom launchers might also store Minecraft instances in non-standard locations.</p></li>
    </ul>

    <h4 class="subsection-title">.minecraft Folder (Location, Structure)</h4>
    <p class="body-paragraph">
        Minecraft relies on a root directory, commonly referred to as the <code class="path-example">.minecraft</code> folder, to store essential game files, assets, logs, mods, resource packs, and user data.
    </p>
    <ul>
        <li><p class="list-item">Default Location: By default, the <code class="path-example">.minecraft</code> folder is located in the user's AppData directory: <code class="path-example">C:\Users\{username}\AppData\Roaming\.minecraft</code>.</p></li>
        <li><p class="list-item">Variable Location: However, the location is not fixed. Players or custom launchers (like MultiMC) can configure Minecraft to use a different root directory, potentially placing it anywhere on the system's storage devices. Relying solely on the default path can lead to missed evidence.</p></li>
        <li><p class="list-item">Finding the Correct Folder: The most reliable way to locate the active <code class="path-example">.minecraft</code> folder for the currently running game instance during a ScreenShare is:</p>
            <ul>
                <li><p class="list-item">Inside Minecraft, go to Options.</p></li>
                <li><p class="list-item">Select Resource Packs.</p></li>
                <li><p class="list-item">Click Open Pack Folder (or similar wording depending on the version/language).</p></li>
                <li><p class="list-item">This opens the <code class="path-example">resourcepacks</code> subfolder. Navigate one level up to find the correct root <code class="path-example">.minecraft</code> (or equivalent) directory being used by that specific instance.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Structure: Within the root folder, various subdirectories organize game data. For cheat detection, the <code class="path-example">versions</code>, <code class="path-example">mods</code>, <code class="path-example">libraries</code>, and <code class="path-example">logs</code> folders are often of particular interest.</p></li>
    </ul>
    <div class="note-box"><p class="body-paragraph">Note: Detection methods for cheats generally follow the patterns described for their respective categories (Ghost, Injection, External, Autoclicker).</p></div>

    <h3 class="subsection-title">Specific Analysis for Minecraft</h3>

    <p class="body-paragraph">
        ScreenSharing in Minecraft often involves targeted analysis methods.
    </p>

    <h4 class="subsection-title">Forge Mod Analysis (Weight, Decompilation, SHA256 Hash, Unloaded Mod)</h4>

    <p class="body-paragraph">
        This multi-phase process details how to scrutinize Forge mods for potential cheats.
    </p>

    <h5 class="subsection-title">Phase 1: Preparation and Locating the Correct <code class="path-example">mods</code> Folder</h5>

    <p class="body-paragraph">
        Precisely identifying the <code class="path-example">.minecraft</code> folder and the <code class="path-example">mods</code> subfolder in use is the essential first step.
    </p>
    <ul>
        <li><p class="list-item">Enable Hidden File Viewing: Before starting, ensure Windows display settings are configured to show hidden files, folders, and protected operating system files. This is crucial as the <code class="path-example">mods</code> folder itself might be hidden.</p></li>
        <li><p class="list-item">Locate the Active <code class="path-example">.minecraft</code> Folder:</p>
            <ul>
                <li><p class="list-item">Recommended Method (In-Game): Do not rely solely on the standard <code class="path-example">%appdata%\.minecraft</code> path, as it might not be the correct one (e.g., due to alternative launchers like MultiMC or a moved folder).</p></li>
                <li><p class="list-item">Launch Minecraft and navigate to Options > Resource Packs.</p></li>
                <li><p class="list-item">Click on Open resource pack folder.</p></li>
                <li><p class="list-item">Navigate up one level (from <code class="path-example">resourcepacks</code> to the parent folder). This is the <code class="path-example">.minecraft</code> folder currently used by the game.</p></li>
                <li><p class="list-item">Identify the <code class="path-example">mods</code> subfolder within this path.</p></li>
                <li><p class="list-item">Absolute Best Method (System Informer): Use System Informer. Filter the <code class="path-example">javaw.exe</code> process for strings containing <code class="path-example">\mods</code>. Examine the results to identify the exact path being accessed by the running Minecraft instance.</p></li>
            </ul>
        </li>
    </ul>

    <h5 class="subsection-title">Phase 2: Preliminary Checks on the <code class="path-example">mods</code> Folder</h5>

    <p class="body-paragraph">
        Before analyzing individual files, examine the <code class="path-example">mods</code> folder itself.
    </p>
    <ul>
        <li><p class="list-item">Check Last Modified Date: Verify the date and time the <code class="path-example">mods</code> folder was last modified.</p></li>
            <div class="attention-box"><p class="body-paragraph">▲ Critical Indicator (Potentially Bannable): If the modification date/time is immediately before the start of the ScreenShare check, it strongly suggests tampering (adding, removing, or replacing files). Many servers consider this a direct bannable offense.</p></div>
    </ul>

    <h5 class="subsection-title">Phase 3: Detailed Analysis of Mod Files (<code class="file-extension">.jar</code>)</h5>

    <p class="body-paragraph">
        Examine every <code class="file-extension">.jar</code> file present in the identified <code class="path-example">mods</code> folder.
    </p>
    <ul>
        <li><p class="list-item">Identifying Mods in Use: While the game is running, attempt to move the <code class="file-extension">.jar</code> files out of the <code class="path-example">mods</code> folder. Files that cannot be moved are currently loaded and locked by Minecraft's <code class="path-example">javaw.exe</code> process (or potentially by another application, though this usually involves different bypass techniques).</p></li>
        <li><p class="list-item">File Size (Weight) Analysis: Check the size of each <code class="file-extension">.jar</code> file. Legitimate mods usually have predictable sizes for specific versions.</p>
            <ul>
                <li><p class="list-item">Suspicion: A significantly different size (too large or too small) compared to the expected standard for that specific mod and version is a red flag.</p></li>
                <li><p class="list-item">Example: A Togglesneak 1.8.9 mod weighing 64 KB instead of the standard ~24 KB requires further investigation. Note down mods with anomalous sizes.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Content Analysis via Decompilation (Luyten, Recaf): Use a Java decompiler (e.g., Luyten, Recaf) to examine the source code of suspicious mods (those with anomalous size or flagged for other reasons).</p>
            <ul>
                <li><p class="list-item">Procedure: Drag the suspicious <code class="file-extension">.jar</code> file into the decompiler window.</p></li>
                <li><p class="list-item">What to Look For:</p>
                    <ul>
                        <li><p class="list-item">Suspicious Classes/Packages: Names suggesting cheat functionalities (e.g., autoclicker, reach, killaura, velocity, aimassist, selfdestruct, fly, speed).</p></li>
                        <li><p class="list-item">Unexpected Code: Functionality irrelevant to the mod's stated purpose (e.g., autoclicker code within a purely cosmetic mod).</p></li>
                        <li><p class="list-item">Obfuscation: Code made intentionally unreadable using generic or nonsensical class/method/variable names (e.g., a, b, c, special characters, excessively long random strings).</p></li>
                    </ul>
                </li>
                <div class="attention-box"><p class="body-paragraph">▲ Critical Indicator (Potentially Bannable): Obfuscation is frequently used to hide malicious code. Many servers ban for obfuscated mods due to the inability to quickly verify their legitimacy during a ScreenShare.</p></div>
            </ul>
        </li>
        <li><p class="list-item">Integrity Verification via Hash (SHA256 / HashMyFiles): This method verifies if a file, even if seemingly legitimate (e.g., Optifine), has been modified from its official release.</p>
            <ul>
                <li><p class="list-item">Tools: Use hash calculators like HashMyFiles or system-integrated tools (e.g., Get-FileHash in PowerShell).</p></li>
                <li><p class="list-item">Procedure:</p>
                    <ol>
                        <li><p class="list-item">Calculate the SHA256 hash of the player's <code class="file-extension">.jar</code> file.</p></li>
                        <li><p class="list-item">Obtain the official SHA256 hash of the exact same version of the mod from reliable sources (e.g., the mod's official download page, a trusted mod database like CurseForge or Modrinth).</p></li>
                        <li><p class="list-item">Compare the hashes.</p></li>
                    </ol>
                </li>
                 <div class="attention-box"><p class="body-paragraph">▲ Critical Indicator (Potentially Bannable): If the hashes do not match, the file has been modified and is therefore illegitimate. It is crucial to compare the exact version (including build numbers if applicable) to avoid false positives.</p></div>
            </ul>
        </li>
    </ul>

    <h5 class="subsection-title">Phase 4: Detecting "Unloaded" Mods (Memory Analysis)</h5>

    <p class="body-paragraph">
        This technique identifies mods that were removed from the <code class="path-example">mods</code> folder after the game started but might still be referenced in the game's memory.
    </p>
    <ul>
        <li><p class="list-item">Tools: Use System Informer (or Process Hacker) with administrator privileges. Ensure the Kernel-Mode Driver is enabled in the options for full access.</p></li>
        <li><p class="list-item">Procedure:</p>
            <ol>
                <li><p class="list-item">Find Minecraft's <code class="path-example">javaw.exe</code> process in the process list.</p></li>
                <li><p class="list-item">Right-click the process > Properties > Memory tab > Strings button.</p></li>
                <li><p class="list-item">Configure search options: Set minimum length to 4 or 5, select Mapped and Extended Unicode, deselect Image.</p></li>
                <li><p class="list-item">Click the Filter button and choose Contains (case-insensitive).</p></li>
                <li><p class="list-item">Paste the full path of the player's active <code class="path-example">mods</code> folder (identified in Phase 1) into the filter text box.</p></li>
            </ol>
        </li>
        <li><p class="list-item">Result Analysis: System Informer will list the full paths of <code class="file-extension">.jar</code> files found referenced within the <code class="path-example">javaw.exe</code> process's memory.</p></li>
        <li><p class="list-item">Comparison: Compare the list obtained from System Informer with the <code class="file-extension">.jar</code> files currently present on the disk in the <code class="path-example">mods</code> folder.</p></li>
        <div class="attention-box"><p class="body-paragraph">▲ Critical Indicator (Potentially Bannable): If System Informer shows the path of a mod (e.g., <code class="path-example">C:\Users\...\.minecraft\mods\CheatMod.jar</code>) that is no longer physically present in the folder, it indicates the mod was likely "unloaded" and then removed, moved, or renamed mid-session to evade detection.</p></div>
    </ul>

    <h5 class="subsection-title">Bonus Method (Preferably use before Phase 3): HabibiModAnalyzer</h5>
    <p class="body-paragraph">
        Over the years, increasingly advanced programs have been created that automate significant parts of the analysis. For mods, a useful tool is the HabibiModAnalyzer PowerShell script created by HadronCollision.
    </p>
    <ul>
        <li><p class="list-item">Functionality: This script verifies the integrity of mods by checking their file hashes against the Modrinth database, ensuring they haven't been tampered with. Additionally, it features generic cheat detection capabilities and can identify the download origin of a file using Zone.Identifier information.</p></li>
        <li><p class="list-item">Command:</p></li>
    </ul>
    <pre><code class="code-block">Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass; Invoke-Expression (Invoke-RestMethod https://raw.githubusercontent.com/HadronCollision/PowershellScripts/refs/heads/main/HabibiModAnalyzer.ps1)
</code></pre>

    <h4 class="subsection-title">Javaedit (Modified Minecraft Versions) - Detection via Hash/Content</h4>
    <p class="body-paragraph">
        Javaedit refers to versions of Minecraft (often appearing as standard vanilla versions) that have been internally modified at the bytecode level to include cheats (like enhanced Reach or modified hit detection).
    </p>
    <ul>
        <li><p class="list-item">Detection: The primary and most reliable detection method involves comparing the SHA256 hash of the core Minecraft <code class="file-extension">.jar</code> file used by the player (typically found within the corresponding subdirectory in the <code class="path-example">versions</code> folder) against the official SHA256 hash for the exact same vanilla version.</p></li>
        <li><p class="list-item">Verification: Any discrepancy between the player's file hash and the official hash proves the file has been tampered with and is not a legitimate vanilla version. Ensure you are comparing against the hash of the exact version number (e.g., 1.8.9, 1.16.5).</p></li>
    </ul>

    <hr>

    <h2 class="section-title">Section 5: Mouse, Macro, and Input Analysis in ScreenSharing</h2>

    <p class="body-paragraph">
        Analyzing mouse settings, macros, and input methods is a crucial aspect of ScreenSharing, particularly when investigating players suspected of using autoclickers or achieving unusually high clicks-per-second (CPS). Cheaters may leverage both third-party software and features within their mouse's own software to gain an unfair advantage. This section details how to investigate these methods.
    </p>

    <h3 class="subsection-title">1. Understanding Mouse Input Manipulation</h3>

    <p class="body-paragraph">
        Minecraft is one of the few games where click speed can significantly impact gameplay outcomes. Players constantly seek ways to click faster, sometimes resorting to methods that exploit mouse hardware or use external software. This makes mouse and input analysis a frequent point of contention and investigation during ScreenShares. Key areas of focus include:
    </p>
    <ul>
        <li><p class="list-item">Macros: Pre-programmed sequences of actions assigned to mouse buttons.</p></li>
        <li><p class="list-item">Debounce Time: A hardware/software feature that can be manipulated on some mice to allow for faster click registration, often associated with "mouse abuse" techniques.</p></li>
        <li><p class="list-item">Third-Party Software: Tools like X-Mouse Button Control that allow extensive input customization, often banned by servers.</p></li>
    </ul>

    <h3 class="subsection-title">2. Macro Analysis</h3>
    <h4 class="subsection-title">Definition and Purpose in Cheating</h4>

    <p class="body-paragraph">
        Macros, in the context of Minecraft cheating, are automated sequences of instructions assigned to a mouse button (or keyboard key). They are primarily used to artificially increase click speed, simulating rapid clicks much faster than humanly possible through standard clicking. While some basic macro functionality might be legitimate in other contexts, within Minecraft ScreenSharing, they are often investigated as potential autoclickers or unfair advantages.
    </p>
    <div class="note-box"><p class="body-paragraph">Note: Software like Timer Resolution is generally not categorized alongside macro programs like XMBC.</p></div>

    <h4 class="subsection-title">General Detection Strategy</h4>

    <p class="body-paragraph">
        Detecting macros involves examining the configuration settings and associated files of the player's mouse software. Most gaming mice come with proprietary software that allows users to create and save macros. These settings are typically stored in specific configuration files or database entries within the system's AppData or ProgramData folders.
    </p>

    <h4 class="subsection-title">Detection by Mouse Brand</h4>

    <p class="body-paragraph">
        The location of macro configuration files varies by manufacturer. Here are the known paths for several common brands:
    </p>
    <ul>
        <li><p class="list-item">Logitech:</p>
            <ul>
                <li><p class="list-item">Logitech Gaming Software (LGS): <code class="path-example">%localappdata%\Logitech\Logitech Gaming Software\settings.json</code> (or similar <code class="file-extension">.xml</code>/<code class="file-extension">.json</code> files)</p></li>
                <li><p class="list-item">Logitech G HUB: <code class="path-example">%localappdata%\LGHUB\settings.db</code> (SQLite database) or related files.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Razer:</p>
            <ul>
                <li><p class="list-item">Synapse 2: Check installation folders and AppData for profile/macro files.</p></li>
                <li><p class="list-item">Synapse 3: <code class="path-example">C:\ProgramData\Razer\Synapse3\Accounts\</code> and <code class="path-example">%localappdata%\Razer\Synapse3\Log\</code> (Logs might indicate macro usage or profile changes). Macro configurations might be stored server-side or within complex profile structures.</p></li>
            </ul>
        </li>
        <li><p class="list-item">SteelSeries:</p>
            <ul>
                <li><p class="list-item">SteelSeries Engine 3: <code class="path-example">%localappdata%\steelseries-engine-3-client\Local Storage\leveldb\</code> (LevelDB database, requires specialized tools to read reliably) or related configuration files.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Roccat:</p>
            <ul>
                <li><p class="list-item">Roccat Swarm: <code class="path-example">%appdata%\ROCCAT\SWARM\macro\custom_macro_list.xml</code> (or similar <code class="file-extension">.xml</code> files within the Swarm profile directory).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Red Dragon:</p>
            <ul>
                <li><p class="list-item"><code class="path-example">%homepath%\Documents\M&lt;ModelNumber&gt; Gaming Mouse\MacroDB\</code> (or similar paths within Documents, where &lt;ModelNumber&gt; varies). Look for files like <code class="path-example">MacroData.db</code> or similar.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Glorious:</p>
            <ul>
                <li><p class="list-item"><code class="path-example">%appdata%\BY-COMBO2\</code> (Check for configuration files like <code class="file-extension">.json</code> or <code class="file-extension">.ini</code>).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Cooler Master: (Check common locations like AppData/Local or AppData/Roaming for Cooler Master software folders and associated config files).</p></li>
        <li><p class="list-item">Bloody: (Check installation directory and AppData folders for profile/macro configuration files, often <code class="file-extension">.ini</code> or proprietary formats).</p></li>
        <li><p class="list-item">Mad Catz: (Check installation directory and AppData for profile/macro settings).</p></li>
        <li><p class="list-item">Mars Gaming: (Check installation directory and AppData for profile/macro settings, often <code class="file-extension">.xml</code> or <code class="file-extension">.ini</code>).</p></li>
    </ul>

    <p class="body-paragraph">
        Analysis Steps:
    </p>
    <ol>
        <li><p class="list-item">Identify the player's mouse brand and model.</p></li>
        <li><p class="list-item">Navigate to the corresponding paths listed above.</p></li>
        <li><p class="list-item">Examine the modification dates of configuration files or folders. Recent modifications before the ScreenShare are suspicious.</p></li>
        <li><p class="list-item">If possible (e.g., for <code class="file-extension">.xml</code>, <code class="file-extension">.json</code>, <code class="file-extension">.ini</code> files), open the configuration files in a text editor and look for sections defining macros, key bindings simulating rapid clicks, or custom scripts. Databases like SQLite (<code class="file-extension">.db</code>) or LevelDB require appropriate viewers.</p></li>
        <li><p class="list-item">Open the mouse's official software and check the macro/binding settings directly. Compare these settings with any findings from the configuration files.</p></li>
    </ol>

    <h3 class="subsection-title">3. Debounce Time Analysis</h3>
    <h4 class="subsection-title">Definition and Mouse Abuse</h4>

    <p class="body-paragraph">
        Debounce time is a built-in delay mechanism in mouse switches and firmware designed to prevent a single physical click from registering multiple inputs (double-clicking). This happens because the physical switch components can "bounce" upon actuation. A typical debounce time is around 10ms or 16ms, during which the mouse ignores further signals from the switch after the initial click.
    </p>
    <p class="body-paragraph">
        Mouse Abuse occurs when players use mice with adjustable or inherently low debounce times (often below 10ms) combined with specific clicking techniques (like butterfly clicking or drag clicking). These techniques physically vibrate the switch rapidly, and a low debounce time allows these vibrations to register as multiple distinct clicks, leading to artificially inflated CPS far exceeding what's possible with standard clicking on a standard mouse.
    </p>

    <h4 class="subsection-title">Server Rules Context</h4>

    <p class="body-paragraph">
        Because manipulating debounce time provides a significant, hardware-based advantage in click speed, many servers consider setting debounce time below a certain threshold (commonly 10ms) a bannable offense, equating it to an unfair advantage or a form of hardware cheating.
    </p>

    <h4 class="subsection-title">General Detection Strategy</h4>

    <p class="body-paragraph">
        Debounce time modification is exclusively controlled through the mouse's proprietary software, if the mouse model supports it. There are no generic third-party tools to alter debounce time, as it's tied to the mouse's specific hardware and firmware.
    </p>
    <p class="body-paragraph">
        Detection involves:
    </p>
    <ul>
        <li><p class="list-item">Identifying if the player's mouse model allows debounce time adjustment via software.</p></li>
        <li><p class="list-item">Checking the mouse software settings directly for the configured debounce value.</p></li>
        <li><p class="list-item">Examining the software's configuration files (often the same files used for macros) for saved debounce settings.</p></li>
    </ul>

    <h4 class="subsection-title">Detection by Mouse Brand</h4>

    <p class="body-paragraph">
        Not all mice allow debounce adjustment. Here’s a breakdown of relevant brands mentioned:
    </p>
    <ul>
        <li><p class="list-item">Glorious: Debounce time is adjustable via a software slider. Check the configuration files in <code class="path-example">%appdata%\BY-COMBO2\</code>.</p></li>
        <li><p class="list-item">Cooler Master: Similar to Glorious, often uses a software slider. Check software configuration files in AppData.</p></li>
        <li><p class="list-item">Roccat: Some models feature a "Zero Debounce" switch/setting. Crucially, Roccat mice (especially older models) are widely considered to have inherently low debounce times (&lt; 10ms) regardless of the software setting due to hardware characteristics.</p></li>
            <ul>
                <li><p class="list-item">Ban Logic: If a player uses a Roccat mouse, achieves high CPS (e.g., 20+) indicative of mouse abuse, and the server bans debounce &lt; 10ms, this can be grounds for a ban even if the software setting appears normal. However, context is vital. Finding a Roccat mouse during a check for unrelated cheats (like reach) without observing high CPS is not sufficient grounds for a ban based on debounce alone, though it might be noted.</p></li>
            </ul>
        <li><p class="list-item">Bloody: Similar to Roccat, Bloody mice often have adjustable debounce via sliders but are also known for being inherently faulty with low effective debounce times (&lt; 10ms) even when set higher in software. The same ban logic and context considerations as Roccat apply.</p></li>
        <li><p class="list-item">Red Dragon: Some models allow debounce adjustment via software sliders. Check configuration files in <code class="path-example">%homepath%\Documents\M&lt;ModelNumber&gt; Gaming Mouse\MacroDB\</code> or similar.</p></li>
        <li><p class="list-item">Mad Catz: Known for having virtually no debounce timer or double-click prevention mechanisms on some models. The same ban logic and context considerations as Roccat/Bloody apply if mouse abuse is suspected.</p></li>
        <li><p class="list-item">Mars Gaming: Implements debounce time adjustment via software sliders. Check configuration files in AppData.</p></li>
    </ul>
    <p class="body-paragraph">
        Important Consideration: Always correlate findings related to low debounce time with the reason for the ScreenShare and observed player behavior (e.g., actual high CPS). Do not issue bans solely based on the possession of a specific mouse model unless server rules explicitly state this or clear mouse abuse was witnessed.
    </p>

    <hr>

    <h2 class="section-title">Sezione 6: Manual SS Techniques (Basic and Intermediate)</h2>

    <h3 class="subsection-title">Introduction to Process and Memory Analysis</h3>

    <p class="body-paragraph">
        Process and memory analysis is a cornerstone technique used during ScreenSharing sessions. It involves examining the computer's running processes and their associated memory contents to find evidence of unauthorized software (cheats) or suspicious activities. Unlike examining files stored on disk, memory analysis focuses on volatile data – information that exists only while the system or a specific process is running. This allows ScreenSharers to potentially find cheats that are designed to run without leaving obvious traces on the hard drive or cheats that have been recently executed. Tools like Process Hacker (now succeeded by System Informer) are essential for this type of analysis.
    </p>

    <h3 class="subsection-title">Process Hacker / System Informer: Introduction and Configuration</h3>

    <p class="body-paragraph">
        System Informer (the updated version of the discontinued Process Hacker) is a powerful, free, and multi-purpose tool essential for ScreenSharing. It allows users to monitor system resources, debug software, and, crucially for ScreenSharing, inspect the memory of running processes and services to detect cheats.
    </p>

    <h4 class="subsection-title">Key Capabilities for ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">Process Visualization: Displays all running processes, services, drivers, and network connections, including those hidden or inactive.</p></li>
        <li><p class="list-item">Memory Inspection: Allows deep examination of the memory space allocated to each process.</p></li>
        <li><p class="list-item">String Searching: Enables searching within a process's memory for specific text strings or patterns (using regular expressions) that might indicate the presence or execution of cheats.</p></li>
        <li><p class="list-item">Detailed Information: Provides insights into process start times, loaded modules (DLLs), network activity, and resource usage.</p></li>
    </ul>

    <h4 class="subsection-title">Configuration: Enabling Kernel Mode Driver</h4>

    <p class="body-paragraph">
        To access low-level processes (like <code class="path-example">csrss.exe</code> or antivirus processes) and overcome potential permission issues, especially on modern Windows versions (like Windows 11), enabling the Kernel Mode Driver is crucial.
    </p>
    <ol>
        <li><p class="list-item">Download and Install: Obtain System Informer from the official source (<code class="path-example">https://systeminformer.sourceforge.io/</code>).</p></li>
        <li><p class="list-item">Run as Administrator: Always start System Informer with administrative privileges.</p></li>
        <li><p class="list-item">Access Options: Go to the Options menu.</p></li>
        <li><p class="list-item">Enable Kernel Driver: Navigate to the General tab and check the box for Enable Kernel-Mode Driver.</p></li>
        <li><p class="list-item">Restart: Close and restart System Informer as administrator for the changes to take effect. You might encounter an error message if the driver is incompatible with a very recent Windows update, but typically it will be updated by the developers.</p></li>
    </ol>

    <h4 class="subsection-title">General Process Filtering Steps:</h4>
    <ol>
        <li><p class="list-item">Locate Process: Find the target process (e.g., <code class="path-example">explorer.exe</code>) in the main window.</p></li>
        <li><p class="list-item">Properties: Right-click the process and select Properties.</p></li>
        <li><p class="list-item">Memory Tab: Go to the Memory tab.</p></li>
        <li><p class="list-item">Strings: Click the Strings button (or navigate via Options > Strings in older versions).</p></li>
        <li><p class="list-item">Configure Search:</p>
            <ul>
                <li><p class="list-item">Set Minimum length: Typically 4 or 5. This filters out very short, usually irrelevant strings.</p></li>
                <li><p class="list-item">Select Image, Mapped, and Private. (Note: Sometimes is suggest unchecking Image to reduce noise, but selecting all is a common starting point for newer SSer.)</p></li>
                <li><p class="list-item">Ensure Extended Unicode is checked to capture a wider range of characters.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Filter: Click OK to view strings. Use the Filter button in the results window. Choose Contains (case-insensitive) for simple keyword searches or Regex (case-insensitive) for pattern-based searches.</p></li>
    </ol>
    <div class="note-box"><p class="body-paragraph">Important Note: When the string search is running, avoid letting the user press Esc, as this can stop the filtering process prematurely. Clicking another window or holding Ctrl can sometimes mitigate this.</p></div>

    <h3 class="subsection-title">Specific Processes to Analyze and Search Patterns</h3>

    <p class="body-paragraph">
        During a ScreenShare, certain processes are more likely to contain relevant information or traces of cheats. Here are some key processes and common search patterns:
    </p>

    <h4 class="subsection-title">1. <code class="path-example">explorer.exe</code> (Windows Explorer)</h4>
    <ul>
        <li><p class="list-item">Function: Manages the Windows shell (desktop, taskbar, file explorer). It indexes files and paths processed by the Windows Indexer.</p></li>
        <li><p class="list-item">Reliability: Often considered unreliable for definitive proof due to high volatility and potential for false positives or easy bypasses. Use findings as starting points, not sole evidence.</p></li>
        <li><p class="list-item">Common Patterns:</p>
            <ul>
                <li><p class="list-item"><code class="code-block">pcaclient</code> (Contains, case-insensitive): Searches for traces left by the Program Compatibility Assistant (PCA). This can reveal recently executed programs (often the last 10), although modern cheats easily bypass this. Copy the results to Notepad for easier viewing.</p></li>
                <li><p class="list-item"><code class="code-block">file:///</code> (Contains, case-insensitive): Lists files recently viewed or accessed through File Explorer. Can provide an overview but is often cluttered and may not indicate execution. Filter further for specific extensions like <code class="file-extension">.exe</code>, <code class="file-extension">.dll</code>.</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">2. <code class="path-example">csrss.exe</code> (Client Server Runtime Subsystem)</h4>
    <ul>
        <li><p class="list-item">Function: A critical, low-level Windows process managing console windows, thread creation/deletion, and parts of the GUI. It often logs paths of executed files (<code class="file-extension">.exe</code>, <code class="file-extension">.dll</code>).</p></li>
        <li><p class="list-item">Accessibility Issues: Can be protected by antivirus or locked on newer Windows versions (Windows 11+). Enabling the Kernel Mode Driver in System Informer is often necessary to access its memory.</p></li>
        <li><p class="list-item">Filtering Logic: When searching for <code class="file-extension">.exe</code> files, analyzing the <code class="path-example">csrss.exe</code> instance with fewer private bytes. Conversely, when hunting for injected <code class="file-extension">.dlls</code>, the instance with more private bytes.</p></li>
        <div class="note-box"><p class="body-paragraph">Note: When seraching for <code class="file-extension">.exe</code> with a Spoofed / Changed extenion you will need to use the instance with more private bytes.</p></div>
        <li><p class="list-item">Common Patterns (Regex, case-insensitive):</p>
            <ul>
                <li><p class="list-item"><code class="code-block">^[A-Z]:\\.+.exe$</code>: Finds full paths of executed <code class="file-extension">.exe</code> files logged by the process.</p></li>
                <li><p class="list-item"><code class="code-block">^[A-Z]:\\.+.dll$</code>: Finds full paths of loaded <code class="file-extension">.dll</code> files. This is crucial for detecting DLL injections. Analyze unsigned DLLs found here carefully.</p></li>
                <li><p class="list-item"><code class="code-block">^(?:\\\\\?\\)?[A-Za-z]:\\.+$</code>: Finds paths of files with extensions all kind of extentions (even extentionless).</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">3. PlugPlay Service (Sometimes shown under DCOMLaunch)</h4>
    <ul>
        <li><p class="list-item">Function: The Plug and Play service is often involved when Java applications (<code class="file-extension">.jar</code> files) are executed.</p></li>
        <li><p class="list-item">Common Patterns:</p>
            <ul>
                <li><p class="list-item"><code class="file-extension">.jar</code> (Contains, case-insensitive): Search within the instance having the most private bytes (or the identified PlugPlay instance) for paths ending in <code class="file-extension">.jar</code>. This is a primary method for finding executed <code class="file-extension">.jar</code> cheats (like autoclickers).</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">4. <code class="path-example">svchost.exe</code> (-s dps) (Diagnostic Policy Service)</h4>
    <ul>
        <li><p class="list-item"><em class="emphasis">*Function:*</em> Involved in diagnosing connectivity issues but also often logs executed process information.</p></li>
        <li><p class="list-item"><em class="emphasis">*Common Patterns (Regex, case-insensitive):*</em></p>
            <ul>
                <li><p class="list-item"><code class="code-block">^([a-zA-Z]:\\.+)\\?$</code>: This will give you a list of executed exes with their Creation Date aside their name.ù</p></li>
                <li><p class="list-item"><code class="code-block">^!![A-Z]((?!Exe).)*$</code>: This will give you a list of executed .exes but with another extention or extentionless. Example: If i change <code class="path-example">spotify.exe</code> to <code class="path-example">spotify.RedLotus</code> , this string will detect it.</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">5. PcaSvc (Program Compatibility Assistant Service)</h4>
    <ul>
        <li><p class="list-item">Function: Helps with compatibility for older applications but also logs execution data.</p></li>
        <li><p class="list-item">Common Patterns:</p>
            <ul>
                <li><p class="list-item"><code class="code-block">jar</code>: Can sometimes contain traces of executed <code class="file-extension">.jar</code> files, complementing the DCOMLaunch/PlugPlay check.</p></li>
                <li><p class="list-item">Specific executable names: Searching for known cheat filenames.</p></li>
            </ul>
        </li>
        <div class="note-box"><p class="body-paragraph">Note: Make sure to filter for jar and not <code class="file-extension">.jar</code>, this will make sure you will have the possibility to catch <code class="file-extension">.jar</code> executed with other extensions with the <code class="code-block">java -jar</code> command</p></div>
    </ul>

    <h4 class="subsection-title">6. Other Relevant Processes</h4>
    <ul>
        <li><p class="list-item">Task Scheduler Engine (<code class="path-example">taskhostw.exe</code> or scheduler): Analyze for scheduled tasks executing suspicious commands or paths. Filter for <code class="code-block">&lt;Command&gt;</code> or <code class="code-block">&lt;Action&gt;</code> tags, or specific script paths/executables.</p></li>
        <li><p class="list-item">Diagtrack (Connected User Experiences and Telemetry): Sometimes logs command-line executions or script activity if enabled.</p></li>
        <li><p class="list-item"><code class="path-example">SearchIndexer.exe</code>: Can contain cached paths or fragments of executed files/scripts.</p></li>
        <li><p class="list-item"><code class="path-example">ctfmon.exe</code> / <code class="path-example">TextInputHost.exe</code>: Sometimes involved with input methods or macros, might contain relevant strings in specific bypass scenarios.</p></li>
        <li><p class="list-item">Antivirus Processes (e.g., <code class="path-example">MsMpEng.exe</code>): Dumping these can sometimes reveal detected (but perhaps quarantined or allowed) threats or strings related to bypass techniques attempting to evade the AV. Requires Kernel Mode Driver.</p></li>
    </ul>
    <p class="body-paragraph">
        By systematically analyzing these key processes and applying the relevant search patterns using System Informer, ScreenSharers can significantly increase their chances of uncovering evidence of cheating during a ScreenShare session.
    </p>


    <h3 class="subsection-title">Windows Prefetch Analysis (WinPrefetchView / PECmd)</h3>
    <h4 class="subsection-title">Understanding Prefetch</h4>
    <p class="body-paragraph">
        Prefetching is a Windows mechanism designed to enhance system performance by speeding up the launch time of frequently used applications. It achieves this by monitoring application startup and loading necessary data into memory proactively.
    </p>
    <ul>
        <li><p class="list-item">Location: Prefetch files (<code class="file-extension">.pf</code>) are stored in the <code class="path-example">C:\Windows\Prefetch</code> directory.</p></li>
        <li><p class="list-item">File Naming: Each file follows the pattern <code class="path-example">EXECUTABLENAME-HASH.pf</code>. The <code class="path-example">EXECUTABLENAME</code> is the name of the launched application (e.g., <code class="path-example">NOTEPAD.EXE</code>), and the <code class="path-example">HASH</code> is an 8-character hexadecimal value derived from the executable's path, ensuring that executions of the same program from different locations generate distinct Prefetch files.</p></li>
        <li><p class="list-item">Creation: A Prefetch file is typically generated only when an executable (<code class="file-extension">.exe</code>) is run. Other file types, like <code class="file-extension">.jar</code> files, will generate a Prefetch entry for the Java runtime (<code class="path-example">java.exe</code> or <code class="path-example">javaw.exe</code>), while <code class="file-extension">.dll</code> files might generate entries for host processes like <code class="path-example">rundll32.exe</code>, <code class="path-example">regsvr32.exe</code>, or <code class="path-example">dllhost.exe</code> depending on how they are loaded.</p></li>
    </ul>
    <h4 class="subsection-title">Information Stored in Prefetch Files</h4>
    <p class="body-paragraph">
        Each <code class="file-extension">.pf</code> file contains valuable metadata crucial for forensic analysis and understanding application execution patterns:
    </p>
    <ul>
        <li><p class="list-item">Executable Name: The name of the program that was run.</p></li>
        <li><p class="list-item">Run Count: The total number of times the application has been executed.</p></li>
        <li><p class="list-item">Last Run Timestamp: The date and time the application was last executed. This is a primary indicator of execution.</p></li>
        <li><p class="list-item">Up to 8 Previous Run Timestamps: Prefetch files store the timestamps of the last eight executions, providing a recent history.</p></li>
        <li><p class="list-item">Volume Information: Details about the volume (disk drive) where the executable was located during its last run, including the volume name, serial number, and creation date.</p></li>
        <li><p class="list-item">File Metrics: Size of the original executable file.</p></li>
        <li><p class="list-item">Directories Referenced: A list of directories accessed by the application during startup.</p></li>
        <li><p class="list-item">Files Referenced: A list of files and resources (like DLLs) loaded by the application during startup.</p></li>
        <li><p class="list-item">Executable Path Hash: The 8-character hash indicating the path from which the executable was run.</p></li>
    </ul>
    <h4 class="subsection-title">Analysis Tools</h4>
    <p class="body-paragraph">
        While the <code class="path-example">C:\Windows\Prefetch</code> folder can be viewed directly, specialized tools are required to parse the <code class="file-extension">.pf</code> files and extract meaningful information.
    </p>
    <h5 class="subsection-title">WinPrefetchView (Nirsoft)</h5>
    <ul>
        <li><p class="list-item">Functionality: A widely-used GUI tool that parses <code class="file-extension">.pf</code> files and presents the extracted data in a readable format.</p></li>
        <li><p class="list-item">Interface: Typically shows a list of Prefetch entries in the top pane. Selecting an entry displays detailed information in the bottom pane, including run times, run counts, and crucially, the list of files and directories referenced during execution (often referred to as "Indexes" or loaded resources).</p></li>
        <li><p class="list-item">ScreenShare Use Cases:</p>
            <ul>
                <li><p class="list-item">Confirming Execution: Verifying if and when a specific <code class="file-extension">.exe</code> was run by checking its corresponding <code class="file-extension">.pf</code> file's timestamps.</p></li>
                <li><p class="list-item">Detecting Renamed Extensions: Identifying <code class="file-extension">.pf</code> files where the executable name part contains a non-<code class="file-extension">.exe</code> extension (e.g., <code class="path-example">MYCHEAT.TMP-HASH.pf</code>), indicating a possible attempt to disguise an executable.</p></li>
                <li><p class="list-item">Analyzing Loaded Resources: Checking the list of loaded files (DLLs, etc.) within a specific <code class="file-extension">.pf</code> file (e.g., <code class="path-example">java.exe.pf</code> for <code class="file-extension">.jar</code> cheats, <code class="path-example">rundll32.exe.pf</code> for DLL injections) to find traces of suspicious files being loaded.</p></li>
                <li><p class="list-item">Detecting Process Hollowing: In some cases, checking if the "Executable Path" field within WinPrefetchView for a specific <code class="file-extension">.pf</code> entry is empty can be an indicator of process hollowing techniques.</p></li>
            </ul>
        </li>
    </ul>
    <h5 class="subsection-title">PECmd (Eric Zimmerman)</h5>
    <ul>
        <li><p class="list-item">Functionality: A command-line interface (CLI) tool offering more in-depth Prefetch analysis capabilities than typical GUI tools.</p></li>
        <li><p class="list-item">Usage: Executed via CMD or PowerShell, allowing for batch processing and detailed data extraction. A common command structure is <code class="code-block">PECmd.exe -d "C:\Path\To\PrefetchFiles" --csv .</code>, which parses files in the specified directory and outputs the results to CSV files in the current directory.</p></li>
        <li><p class="list-item">Output: Generates detailed CSV files that can be further analyzed using tools like Timeline Explorer or spreadsheet software. This allows for advanced filtering, sorting, and correlation with other forensic artifacts.</p></li>
    </ul>
    <h4 class="subsection-title">Troubleshooting and Evasion Detection</h4>
    <p class="body-paragraph">
        Bypassers may attempt to manipulate or hide Prefetch data. Here's how to address common issues:
    </p>
    <ul>
        <li><p class="list-item">Prefetch Disabled: Verify the status via the registry key:</p>
            <pre><code class="code-block registry-key">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters</code></pre>
            <p class="body-paragraph">A value of 0 for <code class="registry-key">EnablePrefetcher</code> typically means it's disabled.</p></li>
        <li><p class="list-item">SysMain Service Stopped: The <code class="path-example">sysmain</code> (formerly Superfetch) service manages Prefetching. Check its status using the command prompt (as Administrator): <code class="code-block">sc query sysmain</code>. If stopped (STATE : 1 STOPPED), Prefetching is inactive. Restarting this service clears some volatile memory but Prefetch files usually remain until deleted.</p></li>
        <li><p class="list-item">Permission Tampering (CACLS Bypass): Attackers might change the permissions of the <code class="path-example">C:\Windows\Prefetch</code> folder to prevent new <code class="file-extension">.pf</code> files from being written. Check the folder's security settings. Evidence of permission changes can often be found in the USN Journal by querying for security change events related to the Prefetch directory.</p></li>
        <li><p class="list-item">Hidden Prefetch Files: Individual <code class="file-extension">.pf</code> files might be hidden. Use the command prompt (as Administrator) to list all hidden files within the Prefetch directory: <code class="code-block">dir /ah C:\Windows\Prefetch</code>.</p></li>
    </ul>

    <h3 class="subsection-title">LastActivityView: Artifact Aggregation</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        LastActivityView (Nirsoft) is a utility designed to consolidate information about user activity from various sources within the Windows operating system. Instead of checking multiple locations manually, LastActivityView gathers and presents data from several key artifacts in a single, time-sorted interface.
    </p>
    <h4 class="subsection-title">Data Sources</h4>
    <p class="body-paragraph">
        LastActivityView aggregates data from artifacts including, but not limited to:
    </p>
    <ul>
        <li><p class="list-item">Prefetch Files: Information about application executions stored in <code class="path-example">C:\Windows\Prefetch</code>.</p></li>
        <li><p class="list-item">Registry Keys:</p>
            <ul>
                <li><p class="list-item">Recent File History (<code class="path-example">shell:recent</code> related): Tracks recently opened files and folders via shortcuts (<code class="file-extension">.lnk</code> files) often linked to registry keys like RecentDocs.</p></li>
                <li><p class="list-item">Open/Save Dialog History: Data from keys like <code class="registry-key">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU</code>, which logs files recently opened or saved through standard Windows dialog boxes.</p></li>
                <li><p class="list-item">Other relevant registry hives related to application usage and system events.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Event Logs: Certain system and application events recorded by the Windows Event Viewer.</p></li>
        <li><p class="list-item">Recycle Bin: Information about deleted files.</p></li>
    </ul>
    <h4 class="subsection-title">Functionality in ScreenSharing</h4>
    <p class="body-paragraph">
        LastActivityView serves as a valuable tool during ScreenShares for quickly identifying recent activities:
    </p>
    <ul>
        <li><p class="list-item">Detecting File Execution: Can show recently run executables based on Prefetch and registry data.</p></li>
        <li><p class="list-item">Identifying Opened/Saved Files: Useful for spotting recently accessed documents, images, or potentially suspicious files (like cheat configurations) based on OpenSavePidlMRU data.</p></li>
        <li><p class="list-item">Tracking DLL Usage: Particularly useful for detecting the loading or interaction with <code class="file-extension">.dll</code> files, especially those injected using standard methods or having spoofed extensions (e.g., a <code class="file-extension">.dll</code> renamed to <code class="file-extension">.cfg</code>). It often surfaces these interactions via the OpenSavePidlMRU registry data it parses.</p></li>
        <li><p class="list-item">Correlation: By presenting data from multiple sources chronologically, it helps establish timelines and correlate different user actions (e.g., downloading a file, then executing it).</p></li>
    </ul>
    <h4 class="subsection-title">Limitations and Considerations</h4>
    <ul>
        <li><p class="list-item">Dependency on Source Artifacts: The accuracy and completeness of LastActivityView depend entirely on the integrity of the underlying artifacts (Prefetch, Registry, etc.). If these sources have been cleared or tampered with, LastActivityView will not show the corresponding activity.</p></li>
        <li><p class="list-item">Timestamp Accuracy: Timestamps are derived from the source artifacts and reflect the time recorded by that specific artifact, which might be the time of access, modification, or execution depending on the source.</p></li>
        <li><p class="list-item">Relationship to Other Tools: For specific tasks like DLL injection detection via OpenSavePidlMRU, LastActivityView provides a convenient GUI view of the same data accessible directly via <code class="path-example">regedit</code>. It aggregates this with other sources like Prefetch, offering a broader overview than checking just one artifact.</p></li>
    </ul>

    <h3 class="subsection-title">Search Everything: Rapid File System Search</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        Search Everything (voidtools) is a high-performance desktop search utility for Windows that indexes file and folder names on NTFS volumes almost instantaneously. Unlike the built-in Windows search, it creates a lightweight index of filenames and paths, allowing for extremely fast searches across entire drives.
    </p>
    <h4 class="subsection-title">Core Features</h4>
    <ul>
        <li><p class="list-item">Instantaneous Indexing: Indexes NTFS volumes rapidly upon first run and updates the index in real-time as files are added, removed, or renamed.</p></li>
        <li><p class="list-item">Fast Searching: Provides near-instant search results based on filenames and paths.</p></li>
        <li><p class="list-item">Low Resource Usage: Consumes minimal system resources (CPU and RAM) during indexing and searching.</p></li>
        <li><p class="list-item">Advanced Search Syntax: Supports boolean operators, wildcards, regular expressions (regex), and specific filters for size, date, attributes, and even file content.</p></li>
    </ul>
    <h4 class="subsection-title">Usage in ScreenSharing</h4>
    <p class="body-paragraph">
        Search Everything is indispensable during ScreenShares for quickly locating files and investigating potential hiding spots or suspicious items.
    </p>
    <ul>
        <li><p class="list-item">Basic File Location:</p>
            <ul>
                <li><p class="list-item">Quickly find specific files by name (e.g., known cheat filenames, suspicious <code class="file-extension">.exe</code> or <code class="file-extension">.dll</code> files found in other artifacts).</p></li>
                <li><p class="list-item">Use wildcards (*, ?) for partial name searches.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Sorting and Filtering:</p>
            <ul>
                <li><p class="list-item">Sort by Date Modified: Crucial for identifying files created or modified recently, potentially just before the ScreenShare. This is often the default view used by screen sharers.</p></li>
                <li><p class="list-item">Filter by Size: Locate files within a specific size range. Example: <code class="code-block">size:5mb..20mb</code> finds files between 5MB and 20MB (useful as many cheats fall within typical size ranges).</p></li>
                <li><p class="list-item">Filter by Extension: Include or exclude specific file types. Example: <code class="code-block">ext:exe</code> shows only executables; <code class="code-block">!ext:dll !ext:exe</code> excludes DLLs and EXEs.</p></li>
                <li><p class="list-item">Combine Filters: Example: <code class="code-block">da:today !ext:exe !ext:dll size:1mb..30mb</code> finds non-executable, non-DLL files between 1MB and 30MB modified today.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Detecting Hidden or Unusual Files:</p>
            <ul>
                <li><p class="list-item">Unicode/Hollow Characters: Use regex to find files with unusual characters often used for obfuscation: <code class="code-block">regex:[^\x00-\x7FFFFFFF]</code>.</p></li>
                <li><p class="list-item">Extensionless Files: Search for files without an extension, which can sometimes be used to hide executables launched via specific methods (like WMIC): <code class="code-block">ext: </code> (note the space after the colon). Combine with size filters: <code class="code-block">size:1mb..15mb ext:</code>.</p></li>
                <li><p class="list-item">Hidden Files/Folders: Use attribute filters (e.g., <code class="code-block">attrib:h</code>).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Content Searching:</p>
            <ul>
                <li><p class="list-item">Search inside files for specific text strings. This is powerful but slower than filename searching.</p></li>
                <li><p class="list-item">Example: <code class="code-block">content:"This program cannot be run in DOS mode." !ext:exe !ext:dll</code> searches for files containing the standard PE header string but aren't marked as <code class="file-extension">.exe</code> or <code class="file-extension">.dll</code>, potentially revealing renamed executables. Combine with date and size filters for efficiency: <code class="code-block">da:today size:1mb..20mb !ext:exe !ext:dll file: content:"&lt;string&gt;"</code>.</p></li>
            </ul>
        </li>
        <li><p class="list-item">File Previews:</p>
            <ul>
                <li><p class="list-item">Press ALT+P to toggle a preview pane, allowing quick inspection of the contents of text files, images, etc., without opening them directly.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Live Monitoring:</p>
            <ul>
                <li><p class="list-item">Search Everything updates its index in real-time, effectively acting as a live monitor for file system changes (creations, deletions, renames) while it's running.</p></li>
            </ul>
        </li>
    </ul>

    <h3 class="subsection-title">Journal Analysis (JournalTrace / Echo Easy Journal Viewer)</h3>
    <h4 class="subsection-title">The USN Journal (<code class="path-example">$UsnJrnl</code>)</h4>
    <p class="body-paragraph">
        The Update Sequence Number (USN) Journal is a feature of the NTFS file system that maintains a log of changes made to files and directories on a volume. It resides in a hidden system file, typically <code class="path-example">$Extend\$UsnJrnl</code>, and contains different data streams, the most important being <code class="path-example">$J</code>.
    </p>
    <ul>
        <li><p class="list-item">Purpose: To track modifications, creations, deletions, and renames of files and folders. This allows applications (like indexing services or backup software) to efficiently determine what has changed without scanning the entire volume.</p></li>
        <li><p class="list-item">Logged Information: Each entry typically includes a timestamp, the filename, the file reference number (FRN), the parent FRN, a reason code indicating the type of change (e.g., FILE_CREATE, FILE_DELETE, RENAME_NEW_NAME, DATA_OVERWRITE, BASIC_INFO_CHANGE), and source information.</p></li>
        <li><p class="list-item">Persistence: The Journal records events even for files that are subsequently deleted, making it invaluable for forensic analysis.</p></li>
    </ul>
    <h4 class="subsection-title">GUI Parsing Tools</h4>
    <p class="body-paragraph">
        While the USN Journal can be queried using the command-line tool <code class="code-block">fsutil usn readjournal</code>, dedicated GUI tools provide a much more user-friendly way to parse, filter, and analyze the vast amount of data it contains.
    </p>
    <h5 class="subsection-title">JournalTrace (Ponei)</h5>
    <ul>
        <li><p class="list-item">Functionality: A free tool specifically designed to parse and display USN Journal entries from an NTFS volume. Requires administrator privileges.</p></li>
        <li><p class="list-item">Usage Workflow:</p>
            <ol>
                <li><p class="list-item">Launch JournalTrace as Administrator.</p></li>
                <li><p class="list-item">Use the "Drive" menu to "Select" the target NTFS volume (e.g., C:).</p></li>
                <li><p class="list-item">Use the "Drive" menu again to "Scan" the selected volume's Journal.</p></li>
                <li><p class="list-item">Switch to the "Data Grid" layout via the "Layout" menu for a tabular view.</p></li>
                <li><p class="list-item">Sort entries by clicking column headers, typically "Date" (descending) to see the most recent events first.</p></li>
                <li><p class="list-item">Use the filter text boxes above columns like "Name" or "Reason" to search for specific filenames, extensions (<code class="file-extension">.exe</code>, <code class="file-extension">.dll</code>, <code class="file-extension">.pf</code>), or reason codes (delete, rename, create, basic, data extend).</p></li>
            </ol>
        </li>
        <li><p class="list-item">Key Features:</p>
            <ul>
                <li><p class="list-item">Oldest Entry Timestamp: Displays the timestamp of the oldest record found, which can indicate if the Journal was recently cleared (if the oldest entry is very recent).</p></li>
                <li><p class="list-item">Reason Codes: Clearly shows the reason(s) for each logged event (e.g., FileDelete | Close).</p></li>
                <li><p class="list-item">Filtering: Allows effective searching for specific activities related to files or operations.</p></li>
                <li><p class="list-item">Timestamp Accuracy: Generally reliable, though the original transcript noted potential minor ordering issues for events occurring within the same millisecond burst.</p></li>
            </ul>
        </li>
    </ul>
    <h5 class="subsection-title">Echo Easy Journal Viewer (Echo)</h5>
    <ul>
        <li><p class="list-item">Functionality: Another free GUI tool from the creators of the Echo SS Tool, offering a simplified interface for Journal analysis.</p></li>
        <li><p class="list-item">Interface: Presents pre-defined filter buttons for common actions like "Deleted," "Created," "Renamed."</p></li>
        <li><p class="list-item">Usage: Click the reason buttons to filter, and click column headers (like "Timestamp") to sort. Search within columns using filter boxes if available.</p></li>
        <li><p class="list-item">Features: Aims for user-friendliness, making it accessible for beginners. The original transcript mentioned an issue with its feature to open the file's containing folder.</p></li>
    </ul>
    <h4 class="subsection-title">Application in ScreenSharing</h4>
    <p class="body-paragraph">
        Analyzing the USN Journal with these tools is crucial for uncovering activities that might otherwise be missed:
    </p>
    <ul>
        <li><p class="list-item">Tracking File Lifecycle: See when a file was created, renamed (both old and new names are logged), modified, and deleted. Essential for detecting bypasses.</p></li>
        <li><p class="list-item">Detecting Deletions: Confirming the deletion of specific files (cheats, logs, Prefetch files, macros) shortly before or during the ScreenShare.</p></li>
        <li><p class="list-item">Finding Renamed Files: Identifying if a file (e.g., <code class="path-example">cheat.exe</code>) was renamed to something else (e.g., <code class="path-example">legit.txt</code>). Look for RENAME_OLD_NAME and RENAME_NEW_NAME reasons.</p></li>
        <li><p class="list-item">Identifying Attribute Changes: Detecting BASIC_INFO_CHANGE events, which can indicate:</p>
            <ul>
                <li><p class="list-item">Timestomping: Attempts to alter file timestamps.</p></li>
                <li><p class="list-item">Read-Only Attributes: Applying read-only status to files like <code class="file-extension">.pf</code> entries to prevent updates (a Prefetch bypass technique).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Tracking Data Modification: Events like DATA_OVERWRITE or DATA_EXTEND can indicate file content changes, potentially related to hex editing or configuration saving.</p></li>
        <li><p class="list-item">Detecting JnativeHook: Seeing <code class="path-example">JnativeHook*.dll</code> files being created (FILE_CREATE) and subsequently deleted (FILE_DELETE) in the <code class="path-example">%temp%</code> directory is a strong indicator of certain Java autoclickers.</p></li>
        <li><p class="list-item">Verifying Tool Claims: Confirming claims made by other tools (e.g., if LastActivityView shows a recent file access but the file is gone, Journal might show its deletion).</p></li>
    </ul>
    <h4 class="subsection-title">Limitations</h4>
    <ul>
        <li><p class="list-item">Journal Size/Wrapping: The USN Journal has a configurable maximum size. Once full, older entries are overwritten. The timeframe covered depends on disk activity and size settings.</p></li>
        <li><p class="list-item">Journal Clearing: The Journal can be deleted using <code class="code-block">fsutil</code> (though this is highly suspicious and detectable via Event Logs and the Journal's own metadata like "Oldest Entry" time).</p></li>
        <li><p class="list-item">FAT32/exFAT: These file systems do not have a USN Journal. Analysis is impossible on such volumes.</p></li>
    </ul>

    <h3 class="subsection-title">Regedit / Registry Explorer (Registry Viewers - Basic Usage)</h3>
    <h4 class="subsection-title">Understanding the Windows Registry</h4>
    <p class="body-paragraph">
        The Windows Registry is essentially a hierarchical database integrated into the Windows operating system. It stores low-level settings and configuration options for the OS itself, hardware devices, and many installed applications (both system-level and third-party). Developers utilize this database to store values in the form of Keys and Subkeys, which dictate how software and hardware behave.
    </p>
    <p class="body-paragraph">
        Think of it as the central configuration hub. Changes made here can significantly impact system behavior, performance, and functionality. Both legitimate applications (like services, system optimizers) and potentially malicious software can interact with and modify the registry.
    </p>
    <h4 class="subsection-title">Accessing the Registry</h4>
    <ul>
        <li><p class="list-item">Regedit (Registry Editor):</p>
            <ul>
                <li><p class="list-item">The primary built-in tool for viewing and editing the registry.</p></li>
                <li><p class="list-item">Accessed by pressing Win + R, typing <code class="code-block">regedit</code>, and pressing Enter. Administrative privileges are usually required.</p></li>
                <li><p class="list-item">Regedit presents the registry in a tree-like structure, similar to File Explorer, with main sections called "hives" (e.g., HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER).</p></li>
                <li><p class="list-item">Forensic Note: <code class="path-example">Regedit.exe</code> appearing in execution logs (like Prefetch or BAM) indicates direct user interaction with the registry, which can be suspicious during a ScreenShare if occurring shortly before or during gameplay. Regedit also remembers the last key accessed, which might occasionally provide a clue if the user didn't navigate away before closing.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Reg.exe:</p>
            <ul>
                <li><p class="list-item">A command-line utility for interacting with the registry.</p></li>
                <li><p class="list-item">Can be used to add, delete, query, or modify registry keys and values via scripts or direct commands (e.g., <code class="code-block">reg add</code>, <code class="code-block">reg query</code>).</p></li>
                <li><p class="list-item">Forensic Note: <code class="path-example">Reg.exe</code> appearing in execution logs (Prefetch, command history if available) strongly suggests manual or scripted registry manipulation by the user, such as attempts to clear traces (like BAM entries) or modify system settings.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Third-Party Tools (Registry Explorer, etc.):</p>
            <ul>
                <li><p class="list-item">Registry Explorer (by Eric Zimmerman): A powerful GUI-based alternative designed for forensic analysis. It can parse registry hives (the underlying files, typically found in <code class="path-example">C:\Windows\System32\config</code>) even from offline systems or mounted images.</p></li>
                <li><p class="list-item">Features:</p>
                    <ul>
                        <li><p class="list-item">Icons: Provides visual cues, such as a specific icon (often a circled warning sign) indicating the presence of deleted keys or values within a hive, which might still be recoverable. Seeing this on hives like BAM or MuiCache during the current system boot is highly suspicious.</p></li>
                        <li><p class="list-item">Search (CTRL+F): Allows robust searching through keys, value names, value data, and even slack space for specific strings, dates (in UTC), or data sizes.</p></li>
                        <li><p class="list-item">Deleted Value Recovery: Can often recover and display deleted keys/values (highlighted, often in red).</p></li>
                        <li><p class="list-item">Bookmarks: Comes with predefined bookmarks pointing to forensically relevant locations.</p></li>
                        <li><p class="list-item">UTC Time: Displays timestamps in UTC by default.</p></li>
                    </ul>
                </li>
                <li><p class="list-item">Usage: Run as Administrator. It's recommended to load hives at the beginning of a ScreenShare, as it takes a snapshot and doesn't update live, preserving the state at that moment.</p></li>
                <li><p class="list-item">Other Tools: RegScanner, Advanced Regedit offer different interfaces and search capabilities.</p></li>
            </ul>
        </li>
    </ul>
    <h4 class="subsection-title">Forensically Relevant Registry Keys/Locations (Examples from Text)</h4>
    <p class="body-paragraph">
        While a deep dive requires specialized knowledge, the provided text highlights several areas often checked during ScreenShares:
    </p>
    <ul>
        <li><p class="list-item">Prefetch Parameters: <code class="registry-key">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters</code> (Indicates if Prefetch is enabled/disabled).</p></li>
        <li><p class="list-item">Program Compatibility Assistant (PCA): <code class="registry-key">HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\Store</code> (Logs programs interacted with by the compatibility assistant; indicates presence, not necessarily execution time).</p></li>
        <li><p class="list-item">Background Activity Moderator (BAM): <code class="registry-key">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\bam\State\UserSettings\</code> (Stores data about executed applications, including paths and last execution timestamps).</p></li>
        <li><p class="list-item">Recent Files (Open/Save Dialogs): <code class="registry-key">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU\</code> (MRU list for files opened/saved via common dialog boxes).</p></li>
        <li><p class="list-item">File Extension Associations: <code class="registry-key">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\</code> (Lists file extensions known to the user profile).</p></li>
        <li><p class="list-item">WinRAR History: <code class="registry-key">HKEY_CURRENT_USER\SOFTWARE\WinRAR\ArcHistory</code> (Lists recently opened archives if WinRAR is installed).</p></li>
        <li><p class="list-item">Command Processor Autorun: <code class="registry-key">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor</code> (Checking the Autorun value here can reveal if commands, like taskkill, are automatically run when cmd.exe starts, potentially indicating a bypass attempt to disable the command prompt).</p></li>
    </ul>
    <h4 class="subsection-title">Key Considerations for ScreenSharing</h4>
    <ul>
        <li><p class="list-item">Distinguish User vs. System Actions: Not every registry modification is user-initiated. Link registry access/modification times with other artifacts (Prefetch, Journal, Event Logs) to build context.</p></li>
        <li><p class="list-item">Permissions: Users typically cannot modify HKEY_LOCAL_MACHINE (HKLM) keys without administrator privileges. Modifications in HKEY_CURRENT_USER (HKCU) are more common for user-specific settings.</p></li>
        <li><p class="list-item">Timestamps: Registry Explorer often displays timestamps for the last write time to a key. This indicates the last time anything within that key was modified.</p></li>
        <li><p class="list-item">Deleted Values: The presence of deleted values (especially in BAM or UserAssist) can be highly indicative of cleanup attempts.</p></li>
    </ul>

    <h3 class="subsection-title">Event Viewer (Basic Usage for Common IDs)</h3>
    <h4 class="subsection-title">Understanding Event Viewer</h4>
    <p class="body-paragraph">
        Event Viewer is a built-in Windows administrative tool that displays detailed logs about significant events occurring on the computer. These logs cover hardware, software, system problems, security events, and application activity. For ScreenSharing, it's primarily used to find evidence of specific actions like system time changes, log clearing, or attempts to tamper with forensic artifacts like the USN Journal.
    </p>
    <h4 class="subsection-title">Accessing Event Viewer</h4>
    <ul>
        <li><p class="list-item">Press Win + R, type <code class="code-block">eventvwr.msc</code> (or just <code class="code-block">eventvwr</code>), and press Enter.</p></li>
        <li><p class="list-item">Alternatively, search for "Event Viewer" in the Windows search bar.</p></li>
    </ul>
    <h4 class="subsection-title">Log Storage</h4>
    <p class="body-paragraph">
        Event logs are stored as <code class="file-extension">.evtx</code> files, typically located in <code class="path-example">%SystemRoot%\System32\Winevt\Logs\</code> (e.g., <code class="path-example">Application.evtx</code>, <code class="path-example">Security.evtx</code>, <code class="path-example">System.evtx</code>).
    </p>
    <p class="body-paragraph">
        Third-party applications can also create their own event logs.
    </p>
    <h4 class="subsection-title">Checking the EventLog Service</h4>
    <p class="body-paragraph">
        Event Viewer relies on the EventLog service. If this service is stopped, Event Viewer won't function, which is suspicious in itself.
    </p>
    <ul>
        <li><p class="list-item">Check Status: Open an administrative Command Prompt or PowerShell and run <code class="code-block">sc query eventlog</code>.</p></li>
        <li><p class="list-item">Expected State: RUNNING. If it's STOPPED, it's a significant red flag during a ScreenShare.</p></li>
    </ul>
    <h4 class="subsection-title">Key Event Logs and IDs for ScreenSharing (Examples from Text)</h4>
    <p class="body-paragraph">
        Filtering by Event ID is the most common way to quickly find relevant information. Right-click a log (e.g., Security) and select "Filter Current Log...".
    </p>
    <h5 class="subsection-title">System Time Change (Security Log)</h5>
    <ul>
        <li><p class="list-item">Event ID: 4616</p></li>
        <li><p class="list-item">Log: Security (<code class="path-example">Security.evtx</code>)</p></li>
        <li><p class="list-item">Description: Records instances where the system time was changed.</p></li>
        <li><p class="list-item">Context: Look at the "Process Name" or "Process ID" that initiated the change. Changes made by <code class="path-example">svchost.exe</code> might be system adjustments, while changes initiated by <code class="path-example">cmd.exe</code> indicate a manual time change via the command line, which is highly suspicious during a ScreenShare.</p></li>
    </ul>
    <h5 class="subsection-title">Audit Log Clearing (Security Log)</h5>
    <ul>
        <li><p class="list-item">Event ID: 1102</p></li>
        <li><p class="list-item">Log: Security (<code class="path-example">Security.evtx</code>)</p></li>
        <li><p class="list-item">Description: Records when the Security log itself was cleared. This action is almost always performed manually by a user (typically with administrative rights) trying to hide their tracks. This is a strong indicator of malicious intent or bypass attempts.</p></li>
    </ul>
    <h5 class="subsection-title">Journal Deletion (Application Log)</h5>
    <ul>
        <li><p class="list-item">Event ID: 3079 (Source often relates to fsutil)</p></li>
        <li><p class="list-item">Log: Application (<code class="path-example">Application.evtx</code>)</p></li>
        <li><p class="list-item">Description: Indicates that the USN Journal for a volume was deleted. This is a direct attempt to remove filesystem activity traces.</p></li>
    </ul>
    <h5 class="subsection-title">Log File Cleared (Non-Security)</h5>
    <ul>
        <li><p class="list-item">Event ID: 104</p></li>
        <li><p class="list-item">Log: System (<code class="path-example">System.evtx</code>)</p></li>
        <li><p class="list-item">Description: Records when a specific event log (such as Application, System, Setup, or custom logs) was cleared. This event is not generated for clearing the Security log (which uses Event ID 1102).</p></li>
    </ul>
    <h4 class="subsection-title">Key Considerations for ScreenSharing</h4>
    <ul>
        <li><p class="list-item">Timestamps: Event log entries have their own timestamps. Correlate these with other artifacts.</p></li>
        <li><p class="list-item">Filtering: Always use filtering (by Event ID, time range, source) to narrow down the vast amount of log data.</p></li>
        <li><p class="list-item">Context: Don't rely on a single event ID in isolation. Look for patterns or correlating activities around the time of the suspicious event.</p></li>
    </ul>

    <h3 class="subsection-title">Recuva (Deleted File Recovery)</h3>
    <h4 class="subsection-title">Understanding Recuva</h4>
    <p class="body-paragraph">
        Recuva is a popular third-party freeware utility designed to recover files that have been deleted from a storage device (hard drive, USB drive, memory card, etc.). It works by scanning the drive for data blocks that were marked as "free" by the operating system but haven't yet been physically overwritten by new data.
    </p>
    <h4 class="subsection-title">Usage in ScreenSharing</h4>
    <p class="body-paragraph">
        Its primary use during a ScreenShare is to attempt recovery of recently deleted files, especially cheats or tools the user might have tried to remove just before or during the check.
    </p>
    <ul>
        <li><p class="list-item">Scanning: Run Recuva and point it to the relevant drive (e.g., C: drive, a specific USB drive). It can perform a quick or deep scan (deep scans take longer but may find more).</p></li>
        <li><p class="list-item">Identifying Recoverable Files: Recuva lists found files and indicates their recovery chance (often with color codes: Green for excellent, Orange for partial, Red for unrecoverable/overwritten).</p></li>
        <li><p class="list-item">Checking for Suspicious Files: Look for recently deleted executables (<code class="file-extension">.exe</code>), libraries (<code class="file-extension">.dll</code>), scripts (<code class="file-extension">.bat</code>, <code class="file-extension">.ps1</code>), Java archives (<code class="file-extension">.jar</code>), or other suspicious file types. Check their original path and deletion time if available.</p></li>
        <li><p class="list-item">Recovery (Use with Caution): If a suspicious file seems recoverable (Green status), you can attempt to recover it to a different location (like a dedicated evidence folder) for further analysis (e.g., uploading to VirusTotal, opening in a decompiler). Do not recover directly back to the original location.</p></li>
        <li><p class="list-item">FAT32 Context: As mentioned in the source text's discussion on FAT32, tools like Recuva (and FTK Imager) become more relevant on file systems without journaling, as they are primary methods to even see if files were deleted, let alone recover them. Recuva can show if the space previously occupied by a deleted file has been overwritten, which helps determine if recovery is possible.</p></li>
    </ul>
    <h4 class="subsection-title">Limitations</h4>
    <ul>
        <li><p class="list-item">Overwriting: If the disk space previously occupied by the deleted file has been overwritten by new data, recovery is usually impossible.</p></li>
        <li><p class="list-item">Secure Deletion: Files deleted using secure deletion tools (which overwrite data multiple times) cannot be recovered.</p></li>
        <li><p class="list-item">SSDs: Recovery from Solid State Drives (SSDs) can be less reliable due to TRIM commands, which proactively erase unused blocks.</p></li>
    </ul>
    <p class="body-paragraph">
        Recuva serves as a potential tool to find "smoking gun" evidence that the user tried to hide, but its success is never guaranteed.
    </p>

    <hr>

    <h2 class="section-title">Common Bypass Techniques in ScreenSharing</h2>

    <p class="body-paragraph">
        This guide details various techniques employed by individuals to conceal cheating activities during ScreenSharing sessions in environments like Minecraft and FiveM. Understanding these methods and their detection is crucial for effective ScreenSharing.
    </p>

    <h3 class="subsection-title">Introduction to Bypass Categories</h3>

    <p class="body-paragraph">
        Bypass methods generally fall into two categories:
    </p>
    <ul>
        <li><p class="list-item">Generic Methods: These are broad techniques not tied to specific cheats, aiming to obscure general system activity or hinder the ScreenShare process itself.</p></li>
        <li><p class="list-item">Specific Methods: These are tailored techniques designed to hide particular cheats or exploit specific detection blind spots.</p></li>
    </ul>

    <h3 class="subsection-title">Concealment and Obfuscation</h3>

    <p class="body-paragraph">
        A primary goal of bypass techniques is to hide malicious files or activities, making them appear legitimate or disappear entirely. This involves various methods of concealment and obfuscation.
    </p>

    <h4 class="subsection-title">1. Spoofed Extensions</h4>
    <p class="body-paragraph">
        Description: This technique involves disguising executable files (<code class="file-extension">.exe</code>) by changing their file extension to something seemingly innocuous, such as <code class="file-extension">.tmp</code>, <code class="file-extension">.dll</code>, <code class="file-extension">.png</code>, or any other non-executable extension. The user then executes the file using specific Windows utilities that don't rely solely on the extension, like <code class="code-block">Start-Process</code> in PowerShell, or the <code class="code-block">wmic</code> command for certain types of hidden files (like ADS). This can trick ScreenSharers who might only be scanning for standard executable extensions.
    </p>

    <h4 class="subsection-title">2. Unicode Characters in File Names/Paths</h4>
    <p class="body-paragraph">
        Description: Using Unicode characters (especially non-standard, invisible, or characters from alphabets not well-supported by common tools, like Chinese or Georgian) in file names or directory paths can cause issues for certain detection tools and manual inspection methods. Files might render incorrectly, be difficult to type or search for, or even bypass string filters in tools like System Informer if the tool doesn't handle the specific encoding correctly. This can effectively hide cheats in plain sight or within complex directory structures.
    </p>

    <h4 class="subsection-title">3. Alternate Data Streams (ADS)</h4>
    <p class="body-paragraph">
        Description: NTFS Alternate Data Streams (ADS) allow data to be hidden "behind" a standard file or directory without changing its size or apparent content in typical file explorers. A cheater can embed an entire executable (like a cheat <code class="file-extension">.exe</code>) into an ADS attached to a harmless file (e.g., <code class="path-example">notes.txt:cheat.exe</code>). The original <code class="path-example">notes.txt</code> file appears normal, but the hidden stream contains the malicious payload. Execution often requires specific commands like <code class="code-block">wmic process call create "C:\path\notes.txt:cheat.exe"</code> or using utilities like <code class="code-block">forfiles</code>. This bypasses simple file scans looking for standalone cheat files. The text specifically details the <code class="code-block">wmic</code> method involving <code class="code-block">type YourCheat.exe >> LegitimateFile.txt:HiddenStreamName</code> to create the ADS and <code class="code-block">wmic process call create "C:\path\LegitimateFile.txt:HiddenStreamName"</code> to execute it.
    </p>

    <h4 class="subsection-title">4. Code Obfuscation</h4>
    <p class="body-paragraph">
        Description: This applies mainly to cheats distributed as Minecraft mods (<code class="file-extension">.jar</code> files) or standalone Java applications, but can be seen in Fileless bypass or <code class="file-extension">.bat</code> cheats and cleaner. Developers intentionally make the code difficult to understand (obfuscate) to hinder analysis and reverse engineering. This can involve renaming classes and methods to meaningless characters (e.g., <code class="code-block">a.class</code>, <code class="code-block">b()</code>), using complex control flow, encrypting strings, or packing the code. When decompiled, the code appears as a jumbled mess, making it hard for a ScreenSharer to determine its true function quickly.
    </p>

    <h3 class="subsection-title">Steganography</h3>
    <p class="body-paragraph">
        Steganography is a technique employed to conceal data within other, non-secret files or messages. In the context of bypassing ScreenShares, this typically involves embedding malicious code or cheat files within seemingly innocuous carriers like <code class="file-extension">.pdf</code>, <code class="file-extension">.jpg</code>, or <code class="file-extension">.png</code> files. Unlike methods such as Alternate Data Streams (ADS), where data is hidden in a separate NTFS stream, steganography embeds the hidden data directly within the carrier file's structure, although traces may still exist within the NTFS file system metadata.
    </p>
    <p class="body-paragraph">
        The complexity and effectiveness of this bypass increase significantly when combined with other techniques, such as using non-standard execution methods for the hidden payload or employing obfuscation. While detecting the carrier file itself might be straightforward, identifying the hidden content requires deeper analysis of the file's structure and content, often necessitating specialized tools or manual inspection. The goal is to make the malicious payload appear as part of a legitimate file, thereby evading superficial checks. Detecting such hidden data often involves analyzing file integrity, metadata inconsistencies, or unusual file sizes compared to typical examples of the carrier file type.
    </p>

    <h3 class="subsection-title">Artifact and System Manipulation</h3>
    <p class="body-paragraph">
        This category encompasses a range of techniques designed to alter system behavior, modify artifact timestamps or content, or disable functionalities to hinder the ScreenShare process and evade detection.
    </p>

    <h4 class="subsection-title">Timestamp Manipulation (Timestomping)</h4>
    <p class="body-paragraph">
        Timestomping is a prevalent anti-forensic technique focused on altering the timestamps associated with files, particularly the MAC(b) times (Modified, Accessed, Changed, Birth/Creation) stored within the NTFS $STANDARD_INFORMATION ($SI) attribute in the Master File Table (MFT). The primary goal is to make malicious files or modified legitimate files appear older or blend in with legitimate system files, thereby confusing timeline analysis during a ScreenShare.
    </p>
    <p class="body-paragraph">
        Attackers might use tools like Metasploit, dedicated utilities (<code class="path-example">Timestomp.exe</code>), or even built-in tools like PowerShell to modify these timestamps. For example, a cheat file's creation date could be altered to match the installation date of the operating system.
    </p>
    <p class="body-paragraph">
        It's crucial to note that the NTFS file system often maintains a second set of timestamps within the $FILE_NAME ($FN) attribute. Timestomping tools may only alter the $SI timestamps, leaving the $FN timestamps untouched. Comparing the timestamps between the $SI and $FN attributes within the $MFT can often reveal discrepancies indicative of manipulation.
    </p>
    <p class="body-paragraph">
        Furthermore, the USN Journal ($J) records file system activities with accurate timestamps that are generally resistant to tampering by common timestomping tools. An entry like <code class="code-block">Basic Info Change | Close</code> in the USN Journal indicates a modification to a file's attributes or timestamps. Correlating the timestamps found in the USN Journal with those in the
        $MFT ($SI and $FN) is a primary method for detecting timestomping. System time manipulation itself can sometimes be detected by observing anomalies in the sequential timestamps within the USN Journal, potentially using specialized tools like TimeChangeDetect.
    </p>

    <h4 class="subsection-title">Hexadecimal File Modification (Hex Editing)</h4>
    <p class="body-paragraph">
        Hex editing involves directly manipulating the raw binary content (hexadecimal code) of a file. Bypassers may use hex editors (like HxD or ImHex) to alter specific bytes within an executable (<code class="file-extension">.exe</code>) or library (<code class="file-extension">.dll</code>) file.
    </p>
    <p class="body-paragraph">
        This manipulation inevitably changes the file's content, resulting in a different cryptographic hash (MD5, SHA1, SHA256) compared to the original file. Signature verification tools will often flag such files.
    </p>
    <p class="body-paragraph">
        The USN Journal logs activities related to file content changes. Events like <code class="code-block">Data Overwrite | Close</code>, <code class="code-block">Data Extend | Close</code>, or <code class="code-block">Stream Change | Close</code> recorded for the modified file can serve as strong indicators of hex editing, especially when correlated with signature check failures or other suspicious file attributes.
    </p>

    <h4 class="subsection-title">Attribute Manipulation (Read-Only)</h4>
    <p class="body-paragraph">
        File attributes define how the operating system and applications interact with a file. A common manipulation technique involves setting the Read-Only attribute on specific files or artifacts, particularly Prefetch files (<code class="file-extension">.pf</code>).
    </p>
    <p class="body-paragraph">
        When a <code class="file-extension">.pf</code> file is set to read-only, the operating system is prevented from updating its content upon subsequent executions of the corresponding application. This effectively "freezes" the timestamp and execution count within the prefetch file, potentially hiding recent activity. If a ScreenSharer observes a prefetch file with an old timestamp despite other evidence suggesting recent execution, checking its attributes is crucial.
    </p>
    <p class="body-paragraph">
        The act of changing a file's attributes, including setting it to read-only, is logged in the USN Journal typically as <code class="code-block">Basic Info Change | Close</code>. Analyzing Journal entries related to <code class="file-extension">.pf</code> files for this specific reason code can reveal attempts to tamper with prefetch data. Tools like <code class="code-block">dir /ar</code> in CMD can also display files with the read-only attribute set.
    </p>

    <h4 class="subsection-title">Service Thread Suspension</h4>
    <p class="body-paragraph">
        A more advanced technique involves bypassing monitoring or logging mechanisms by suspending specific threads within critical system services, rather than stopping the service entirely. This allows the service process itself (<code class="path-example">svchost.exe</code> or a dedicated process) to appear active in task managers and service lists, while its core functionality is hindered.
    </p>
    <p class="body-paragraph">
        Tools like Process Hacker or System Informer, or even custom scripts (e.g., using PowerShell or C++ code targeting SuspendThread), can be used to target and suspend specific threads associated with dynamic-link libraries (DLLs) loaded by the service. Examples include:
    </p>
    <ul>
        <li><p class="list-item">SysMain (Prefetch): Suspending <code class="path-example">sechost.dll</code> thread might prevent <code class="file-extension">.pf</code> file creation/updates.</p></li>
        <li><p class="list-item">PcaSvc (Program Compatibility Assistant): Suspending <code class="path-example">pcasvc.dll</code> thread might prevent PCA logging.</p></li>
        <li><p class="list-item">DPS (Diagnostic Policy Service): Suspending <code class="path-example">dps.dll</code> thread could interfere with its logging.</p></li>
        <li><p class="list-item">EventLog: Suspending <code class="path-example">wevtsvc.dll</code> thread might disrupt event logging.</p></li>
        <li><p class="list-item">CDPUserSvc: Suspending <code class="path-example">ucrtbase.dll</code> thread could affect connected device logging.</p></li>
    </ul>
    <p class="body-paragraph">
        Detection involves inspecting the running threads of these critical services using tools like System Informer. Suspended threads within these services, especially those linked to their core DLLs, are highly suspicious and indicative of tampering.
    </p>

    <h4 class="subsection-title">Command Prompt (CMD) Obfuscation</h4>
    <p class="body-paragraph">
        To visually conceal commands being executed during a ScreenShare, bypassers might alter the appearance of the Command Prompt (<code class="path-example">cmd.exe</code>) window. This typically involves changing the properties of the console window itself:
    </p>
    <ul>
        <li><p class="list-item">Transparency: Making the CMD window fully or partially transparent.</p></li>
        <li><p class="list-item">Color Matching: Setting the text color to be the same as the background color (e.g., black text on a black background), rendering typed commands invisible.</p></li>
    </ul>
    <p class="body-paragraph">
        While this doesn't prevent the commands from being executed or logged elsewhere (like PowerShell history if applicable, or potentially certain Event Logs), it hinders the ScreenSharer's ability to observe actions in real-time within the CMD window. Detection involves checking the Properties of the CMD window (Right-click on the title bar > Properties > Colors) or using alternative methods to verify command execution.
    </p>

    <h4 class="subsection-title">Disabling System Features via Registry/Group Policy</h4>
    <p class="body-paragraph">
        Windows allows extensive configuration through the Registry and Group Policy Editor (<code class="path-example">gpedit.msc</code>). Bypassers can leverage this to disable or modify system features that are commonly used during ScreenShares.
        Examples include:
    </p>
    <ul>
        <li><p class="list-item">Disabling Program Compatibility Assistant (PCA): Modifying keys under <code class="registry-key">HKLM\SOFTWARE\Policies\Microsoft\Windows\AppCompat</code> or <code class="registry-key">HKCU\Software\Policies\Microsoft\Windows\AppCompat</code> (e.g., setting <code class="registry-key">DisablePCA</code> value) can prevent PCA from logging program executions.</p></li>
        <li><p class="list-item">Preventing Command Prompt Access: Using Group Policy (User Configuration > Administrative Templates > System > Prevent access to the command prompt) or the corresponding registry key (<code class="registry-key">HKCU\Software\Policies\Microsoft\Windows\System\DisableCMD</code>) blocks <code class="path-example">cmd.exe</code>.</p></li>
        <li><p class="list-item">Hiding Drives: Setting the <code class="registry-key">NoDrives</code> value under <code class="registry-key">HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer</code> can hide specific drives from appearing in File Explorer.</p></li>
        <li><p class="list-item">Disabling Run Dialog: Setting the <code class="registry-key">NoRun</code> value under the same Explorer Policies key disables the Win+R Run dialog.</p></li>
        <li><p class="list-item">Disabling Registry Editor Access: A policy exists to prevent access to <code class="path-example">regedit.exe</code>.</p></li>
    </ul>
    <p class="body-paragraph">
        Detection involves querying the specific registry keys and values mentioned using Regedit or Registry Explorer, or using <code class="code-block">gpresult /h gpreport.html</code> in CMD to generate a report of applied Group Policies. Evidence of <code class="path-example">reg.exe</code> or <code class="path-example">regedit.exe</code> usage in execution logs (Prefetch, BAM) shortly before a ScreenShare can also warrant investigation into recent registry changes.
    </p>

    <h3 class="subsection-title">Artifact Clearing Techniques</h3>
    <p class="body-paragraph">
        This set of methods focuses on deleting or wiping data from various system artifacts to remove traces of malicious activity or cheat usage.
    </p>

    <h4 class="subsection-title">Prefetch Clearing</h4>
    <p class="body-paragraph">
        Prefetch files (<code class="file-extension">.pf</code>) located in <code class="path-example">C:\Windows\Prefetch</code> store information about executed applications to speed up subsequent launches. Deleting these files removes direct evidence of program execution timestamps and frequency from this artifact.
    </p>
    <p class="body-paragraph">
        Bypassers may manually delete specific <code class="file-extension">.pf</code> files (e.g., <code class="path-example">cheat.exe-HASH.pf</code>) or clear the entire folder content.
    </p>
    <p class="body-paragraph">
        Detection primarily relies on the USN Journal. The deletion of a <code class="file-extension">.pf</code> file is logged as <code class="code-block">FileDelete | Close</code>. Finding such entries for specific prefetch files, especially shortly before or during the ScreenShare period, is a strong indicator of tampering. If the entire folder is cleared, numerous <code class="code-block">FileDelete</code> entries corresponding to <code class="file-extension">.pf</code> files will appear in the Journal around the same time. Checking the Prefetch folder directly and finding it empty or missing expected entries (like <code class="path-example">AnyDesk.exe</code> or the game's executable) can also be suspicious, especially if the SysMain service is running.
    </p>

    <h4 class="subsection-title">Registry Clearing (BAM, RecentDocs, etc.)</h4>
    <p class="body-paragraph">
        The Windows Registry stores configuration data and activity logs in various keys (hives). Bypassers may target specific keys to remove evidence. Common targets include:
    </p>
    <ul>
        <li><p class="list-item">BAM (Background Activity Moderator): Keys under <code class="registry-key">HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings\</code> or <code class="registry-key">...\bam\State\UserSettings\</code> store records of executed applications.</p></li>
        <li><p class="list-item">RecentDocs: Keys under <code class="registry-key">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs</code> track recently opened documents and files.</p></li>
        <li><p class="list-item">UserAssist: Keys under <code class="registry-key">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist</code> record GUI-based program executions.</p></li>
        <li><p class="list-item">AppCompatFlags (PCA): Keys like <code class="registry-key">Store</code> under <code class="registry-key">HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\</code> relate to PCA logs.</p></li>
        <li><p class="list-item">OpenSavePidlMRU: Keys under <code class="registry-key">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU\</code> track files opened/saved via common dialog boxes.</p></li>
    </ul>
    <p class="body-paragraph">
        Clearing is often done using the Registry Editor (<code class="path-example">regedit.exe</code>) or command-line tools like <code class="path-example">reg.exe</code>. Usage of these tools logged in Prefetch or BAM near the time of the ScreenShare is suspicious.
    </p>
    <p class="body-paragraph">
        Detection methods vary:
    </p>
    <ul>
        <li><p class="list-item">Registry Explorer: This tool can often highlight deleted keys or values within a loaded hive, sometimes marked with specific icons (like a red circled warning for recently deleted BAM entries). Analyzing the relevant hives offline or using live tools like Registry Explorer immediately at the start of the SS is crucial.</p></li>
        <li><p class="list-item">Log Files: Specific applications or system components might log errors if expected registry keys are missing.</p></li>
    </ul>

    <h4 class="subsection-title">USN Journal Clearing</h4>
    <p class="body-paragraph">
        The Update Sequence Number (USN) Journal (<code class="path-example">$J</code> stream within <code class="path-example">$Extend\$UsnJrnl</code>) tracks changes to files and directories on an NTFS volume. Bypassers might attempt to clear the journal to erase the history of file operations (creations, deletions, renames).
    </p>
    <p class="body-paragraph">
        This is typically done using the command <code class="code-block">fsutil usn deletejournal /N C:</code> (or other drive letter). This action completely wipes the existing journal, forcing Windows to create a new, empty one.
    </p>
    <p class="body-paragraph">
        Detection is relatively straightforward:
    </p>
    <ul>
        <li><p class="list-item">Event Logs: The deletion of the USN Journal triggers Event ID 3079 in the Application log. Finding this event indicates intentional clearing.</p></li>
        <li><p class="list-item">FTK Imager / MFTECmd: Analyzing the <code class="path-example">$J</code> stream properties within <code class="path-example">$Extend\$UsnJrnl</code>. A Date Modified timestamp coinciding with the ScreenShare period strongly suggest recent clearing. Comparing the modification dates of <code class="path-example">$J</code> and <code class="path-example">$MAX</code> streams is also vital; if <code class="path-example">$MAX</code> (which tracks journal parameters) was modified recently along with <code class="path-example">$J</code>, it confirms recent manipulation.</p></li>
    </ul>

    <h4 class="subsection-title">Event Log Clearing/Manipulation</h4>
    <p class="body-paragraph">
        Windows Event Logs (<code class="file-extension">.evtx</code> files in <code class="path-example">C:\Windows\System32\winevt\Logs</code>) record system, security, and application events. Bypassers may attempt to clear these logs to remove evidence of specific actions like time changes, service manipulations, or malicious software execution.
    </p>
    <p class="body-paragraph">
        Methods include:
    </p>
    <ul>
        <li><p class="list-item">Using Event Viewer GUI: Right-clicking a log (e.g., Security) and selecting "Clear Log...".</p></li>
        <li><p class="list-item">Using <code class="path-example">wevtutil.exe</code> command: <code class="code-block">wevtutil cl Security</code> clears the Security log.</p></li>
        <li><p class="list-item">Stopping the EventLog Service: Running <code class="code-block">sc stop eventlog</code> (requires specific permissions).</p></li>
        <li><p class="list-item">Log Tampering/Hijacking: Using tools like PsExec to disconnect specific log channels or manipulating <code class="file-extension">.evtx</code> files directly (less common and harder).</p></li>
    </ul>

    <h4 class="subsection-title">Recycle Bin Clearing</h4>
    <p class="body-paragraph">
        Files deleted through standard means (not Shift+Delete) are moved to the Recycle Bin (<code class="path-example">$Recycle.bin</code> folder at the root of each drive). Emptying the Recycle Bin permanently removes these files.
    </p>
    <p class="body-paragraph">
        Detection involves checking the Date Modified timestamp of the hidden <code class="path-example">$Recycle.bin</code> folder itself. If this timestamp is very recent (e.g., just before the ScreenShare), it indicates the bin was recently emptied or modified (e.g., by restoring a file). This requires enabling the viewing of hidden and protected system files in File Explorer options.
    </p>

    <h4 class="subsection-title">File Replacement (Replace Method)</h4>
    <p class="body-paragraph">
        The File Replacement method, often simply called "Replace," is a technique designed to deceive ScreenSharers by substituting a cheat file with a legitimate file that shares the exact same filename.
    </p>
    <p class="body-paragraph">
        The process typically involves:
    </p>
    <ol>
        <li><p class="list-item">A cheat executable (e.g., <code class="path-example">Client.exe</code>) exists in a specific location.</p></li>
        <li><p class="list-item">The bypasser executes the cheat.</p></li>
        <li><p class="list-item">Before or during the ScreenShare, the bypasser deletes the cheat file (<code class="path-example">Client.exe</code>).</p></li>
        <li><p class="list-item">Immediately after, they move or copy a legitimate file (e.g., a renamed <code class="path-example">Notepad.exe</code> or another benign application) into the same location and give it the exact same name as the deleted cheat (<code class="path-example">Client.exe</code>).</p></li>
    </ol>
    <p class="body-paragraph">
        The goal is that when the ScreenSharer finds the file <code class="path-example">Client.exe</code> and inspects it, they see the legitimate application and might miss the fact that a different file with the same name was executed earlier.
    </p>

    <h3 class="subsection-title">Permission and Inheritance Modification</h3>
    <p class="body-paragraph">
        These techniques involve altering access controls for files, folders, or registry keys to hinder detection, prevent logging, or hide malicious configurations.
    </p>

    <h4 class="subsection-title">Using cacls (or similar) for Permission Changes</h4>
    <p class="body-paragraph">
        The <code class="code-block">cacls</code> command (or its more modern counterparts like <code class="code-block">icacls</code>) is a command-line utility for displaying or modifying Access Control Lists (ACLs) for files and folders. Bypassers might use it to change permissions strategically.
    </p>
    <p class="body-paragraph">
        A classic example is modifying the permissions of the Prefetch folder (<code class="path-example">C:\Windows\Prefetch</code>). By removing the system's write permissions or setting the folder to Read-Only, the bypasser prevents the SysMain service from creating new <code class="file-extension">.pf</code> files or updating existing ones, effectively blinding this execution artifact.
    </p>

    <h4 class="subsection-title">Disabling Registry/Folder Inheritance</h4>
    <p class="body-paragraph">
        Inheritance is a mechanism where permissions set on a parent object (folder or registry key) automatically apply to child objects within it. Disabling inheritance breaks this link, allowing child objects to have entirely different permissions from their parent.
    </p>
    <p class="body-paragraph">
        Bypassers might disable inheritance for specific registry keys or folders to:
    </p>
    <ul>
        <li><p class="list-item">Hide Malicious Entries: Set restrictive permissions on a parent key/folder while disabling inheritance and granting access only to a specific subkey/subfolder containing malicious data, making it harder to find during general browsing.</p></li>
        <li><p class="list-item">Prevent Detection: Modify permissions on a specific artifact location (e.g., a logging key in the registry) after disabling inheritance to prevent system services or ScreenSharing tools from reading or writing to it, while the parent key appears accessible. An example mentioned involves disabling inheritance for BAM registry keys.</p></li>
    </ul>
    <p class="body-paragraph">
        Detection requires manually inspecting the Advanced Security Settings for the specific folder or registry key:
    </p>
    <ul>
        <li><p class="list-item">Folders: Properties > Security > Advanced. Check if the "Disable inheritance" button is available (meaning inheritance is currently enabled) or if it says "Enable inheritance" (meaning it's currently disabled). Also, review the permission entries for explicit vs. inherited permissions.</p></li>
        <li><p class="list-item">Registry Keys: In <code class="path-example">regedit</code>, right-click key > Permissions > Advanced. Similar checks for the inheritance status and explicit permissions apply.</p></li>
    </ul>
    <p class="body-paragraph">
        Finding inheritance disabled on critical system locations or artifact repositories without a clear legitimate reason is highly suspicious.
    </p>

    <h3 class="subsection-title">Disk Partition Manipulation for Evasion</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        A technique employed to circumvent standard filesystem journaling involves the creation and subsequent deletion of disk partitions. Standard journaling mechanisms, particularly the USN Journal on NTFS volumes, meticulously log file operations like creation, deletion, modification, and renaming within their designated volume. By creating a separate partition, potentially formatted with a file system lacking robust journaling (like FAT32, although NTFS partitions are also used), malicious activities or cheat storage can be confined to this temporary space.
    </p>
    <h4 class="subsection-title">Mechanism of Evasion</h4>
    <ul>
        <li><p class="list-item">Partition Creation: A new partition is created on the system's storage device. Files, such as cheats or tools intended to be hidden, are then placed or executed within this new partition.</p></li>
        <li><p class="list-item">Activity Logging Avoidance: Since the primary system partition (e.g., C: drive with its own USN Journal) is not directly involved in the file operations occurring on the new partition, its journal remains clean concerning these specific activities. If the new partition uses a file system like FAT32, it inherently lacks journaling capabilities, further obscuring actions taken within it. Even if the new partition is NTFS, its journal is separate from the main system volume's journal.</p></li>
        <li><p class="list-item">Partition Deletion: Before or during a ScreenShare, the separate partition containing the incriminating files or evidence of activity is deleted entirely. This removal aims to erase not just the files but the entire structure that housed them, including any journaling specific to that partition (if it was NTFS).</p></li>
    </ul>
    <h4 class="subsection-title">Forensic Implications</h4>
    <p class="body-paragraph">
        While this method aims to bypass journaling on the default system volume, the act of creating and deleting partitions itself involves significant system-level changes. These structural modifications to the disk layout can leave traces in system event logs. Analysis often involves examining specific event log entries that record volume management operations to identify the creation or deletion times of partitions, potentially correlating them with the ScreenShare session or gameplay times. Furthermore, tools capable of low-level disk analysis might sometimes recover fragments or metadata related to deleted partitions, although this is complex and not always feasible.
    </p>

    <h3 class="subsection-title">Task Scheduler Bypass Techniques</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        The Windows Task Scheduler is a legitimate system component designed to automate tasks by running scripts or programs at predefined times or in response to specific events (like user logon or system boot). Attackers exploit this utility for persistence and evasion. By scheduling malicious executables or scripts to run via the Task Scheduler, they can achieve execution outside the typical user-initiated process flow, potentially bypassing monitoring tools or methods focused on direct user actions or specific session timelines.
    </p>
    <h4 class="subsection-title">Mechanism of Evasion</h4>
    <ul>
        <li><p class="list-item">Task Creation: A new task is created within the Task Scheduler, configured to execute a malicious payload (e.g., a cheat loader, a script to delete logs, or a tool to suspend security services).</p></li>
        <li><p class="list-item">Trigger Configuration: The task's trigger is often set to an event like system startup, user logon, or even a specific time. This ensures the payload runs automatically without direct user interaction during the period of interest (e.g., before a game launch or ScreenShare).</p></li>
        <li><p class="list-item">Execution Context: Tasks can run with different privileges, sometimes even SYSTEM privileges, depending on configuration. This elevated context can aid in performing actions that require higher permissions.</p></li>
        <li><p class="list-item">Bypassing Monitoring: Since the execution is initiated by the Task Scheduler service (<code class="path-example">taskeng.exe</code> or related <code class="path-example">svchost.exe</code> instance) rather than directly by the user double-clicking an executable, it can sometimes bypass certain logging mechanisms like Prefetch (which might only log the scheduler service itself (under <code class="path-example">mmc</code>), not the payload directly depending on how it's launched) or specific user activity monitors. String logging in certain services might also be bypassed if the task runs early in the boot process before monitoring fully initializes.</p></li>
        <li><p class="list-item">Obfuscation: Task names, descriptions, and the executed commands/scripts can be obfuscated or disguised to appear legitimate, making manual inspection more difficult. Unicode characters might also be employed in task names or paths to hinder detection by some tools.</p></li>
    </ul>

    <h3 class="subsection-title">Scripting Languages for Evasion</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        Various scripting languages available on Windows systems, such as PowerShell, Batch (<code class="file-extension">.bat</code>), VBScript (<code class="file-extension">.vbs</code>), Python (<code class="file-extension">.py</code>), AutoIt (<code class="file-extension">.au3</code>), and HTML Applications (<code class="file-extension">.hta</code>), can be misused for malicious purposes, including bypassing security controls and evading detection during ScreenShares. Instead of relying on traditional compiled executables (<code class="file-extension">.exe</code>), attackers use scripts executed by legitimate interpreters already present on the system.
    </p>
    <h4 class="subsection-title">Mechanisms of Evasion</h4>
    <ul>
        <li><p class="list-item">Living-off-the-Land: Scripts leverage built-in Windows interpreters (like <code class="path-example">powershell.exe</code>, <code class="path-example">cmd.exe</code>, <code class="path-example">cscript.exe</code>, <code class="path-example">wscript.exe</code>, <code class="path-example">mshta.exe</code>) or commonly installed ones (<code class="path-example">python.exe</code>, <code class="path-example">AutoIt3.exe</code>). Since these interpreters are legitimate, their execution is less likely to be flagged by basic security software compared to unknown executables.</p></li>
        <li><p class="list-item">Fileless Execution (PowerShell): PowerShell is particularly powerful as it allows for code execution directly in memory without necessarily writing scripts to disk. Commands can be downloaded and executed on-the-fly, or encoded commands can be passed via the command line, minimizing disk artifacts.</p></li>
        <li><p class="list-item">Obfuscation: Scripts are easily obfuscated using various techniques (encoding like Base64, character substitution, breaking code into smaller parts) making static analysis difficult.</p></li>
        <li><p class="list-item">Automation: Scripts excel at automating sequences of actions, such as disabling security services, deleting logs/files (e.g., Prefetch entries, specific registry keys, browser history), modifying system settings, or downloading and executing secondary payloads.</p></li>
        <li><p class="list-item">Interaction with System Components: Scripts can interact directly with Windows APIs, WMI, COM objects, and the .NET framework, enabling complex operations like process injection, registry manipulation, network communication, and persistence mechanisms (e.g., creating scheduled tasks or startup entries).</p></li>
        <li><p class="list-item">HTA Exploitation: HTML Applications (<code class="file-extension">.hta</code> files) can execute embedded scripts (VBScript, JScript) with higher privileges than standard web pages, leveraging <code class="path-example">mshta.exe</code>. This can be used to bypass browser sandbox restrictions and execute arbitrary code when a user opens the HTA file.</p></li>
        <li><p class="list-item">AutoIt for Automation: AutoIt is a legitimate scripting language designed for automating the Windows GUI and general scripting. Attackers misuse it to simulate mouse clicks/keystrokes (like complex macros or autoclickers) or automate malicious tasks. Compiled AutoIt scripts (<code class="file-extension">.exe</code>) can sometimes be harder to reverse-engineer than other script types.</p></li>
    </ul>
    <h4 class="subsection-title">Forensic Implications</h4>
    <p class="body-paragraph">
        Investigating script-based bypasses requires analyzing various artifacts. Key areas include:
    </p>
    <ul>
        <li><p class="list-item">Script Files: Locating the actual script files (<code class="file-extension">.ps1</code>, <code class="file-extension">.bat</code>, <code class="file-extension">.vbs</code>, <code class="file-extension">.py</code>, <code class="file-extension">.au3</code>, <code class="file-extension">.hta</code>) on disk. Check common locations like Temp folders, user profiles, or download directories.</p></li>
        <li><p class="list-item">Execution Logs:</p>
            <ul>
                <li><p class="list-item">PowerShell: Check Event Logs (especially Windows PowerShell operational log, Event IDs 400, 403, 800, 4103, 4104 for script block logging if enabled), PSReadline history file (<code class="path-example">ConsoleHost_history.txt</code>).</p></li>
                <li><p class="list-item">CMD/Batch: Prefetch entries for <code class="path-example">cmd.exe</code>, potentially parent/child process relationships in security event logs (4688).</p></li>
                <li><p class="list-item">VBS/JScript: Prefetch for <code class="path-example">wscript.exe</code> or <code class="path-example">cscript.exe</code>, event logs.</p></li>
                <li><p class="list-item">HTA: Prefetch for <code class="path-example">mshta.exe</code>, browser download history, file system artifacts.</p></li>
                <li><p class="list-item">Python/AutoIt: Prefetch for <code class="path-example">python.exe</code> or <code class="path-example">AutoIt3.exe</code>, installation paths, associated script files.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Memory Analysis: Strings within the interpreter processes (<code class="path-example">powershell.exe</code>, <code class="path-example">cmd.exe</code>, etc.) might contain script content or commands.</p></li>
        <li><p class="list-item">Registry: Evidence of persistence mechanisms set up by scripts (e.g., Run keys, scheduled tasks).</p></li>
    </ul>
    <p class="body-paragraph">
        Detection efforts often focus on monitoring script execution, analyzing script content (especially for obfuscation or suspicious API calls), and examining logs from scripting engines or related system events.
    </p>

    <h3 class="subsection-title">Fileless Malware and Living-off-the-Land Binaries (LOLBins)</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        Fileless malware refers to malicious code that operates primarily in a computer's memory (RAM) rather than relying on traditional files stored on the hard drive. This approach significantly hinders detection by conventional antivirus software, which primarily scans the filesystem for malicious executables. A core component of fileless attacks is the "Living-off-the-Land" (LotL) strategy, where attackers misuse legitimate, pre-installed system tools and utilities—often called LOLBins (Living-off-the-Land Binaries) or LOLBAS (Binaries and Scripts)—to carry out their objectives.
    </p>
    <h4 class="subsection-title">Mechanisms of Evasion</h4>
    <ul>
        <li><p class="list-item">Memory-Resident Operation: The malicious code executes directly in RAM, often injected into legitimate processes, leaving minimal traces on the disk.</p></li>
        <li><p class="list-item">Abuse of Legitimate Tools (LOLBins): Instead of dropping custom malware executables, attackers leverage built-in Windows tools that are trusted and often whitelisted. Common examples include:</p>
            <ul>
                <li><p class="list-item">PowerShell: Used extensively for downloading/executing payloads in memory, reconnaissance, lateral movement, persistence, and manipulating system settings.</p></li>
                <li><p class="list-item">Windows Management Instrumentation (WMI): Used for persistence (via event subscriptions), remote code execution, reconnaissance (gathering system info, checking for AV), and lateral movement. WMI event subscriptions can trigger malicious actions based on system events and often run with high privileges.</p></li>
                <li><p class="list-item">.NET Framework: Exploited through legitimate applications or PowerShell to load and execute malicious assemblies directly in memory, perform complex operations, and interact with Windows APIs.</p></li>
                <li><p class="list-item">Microsoft Office Macros (VBA): Malicious code embedded within Office documents (Word, Excel) that executes when the user enables macros. Often used as an initial infection vector to download and run secondary payloads, frequently leveraging PowerShell or WMI.</p></li>
                <li><p class="list-item">Other LOLBins: Tools like <code class="path-example">regsvr32.exe</code>, <code class="path-example">rundll32.exe</code>, <code class="path-example">certutil.exe</code>, <code class="path-example">bitsadmin.exe</code>, <code class="path-example">mshta.exe</code>, etc., are frequently abused for downloading files, executing code, bypassing application control, and achieving persistence.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Registry-Based Persistence: Fileless malware might store its code or configuration data within the Windows Registry, configuring legitimate processes or services to load and execute this data upon startup or specific triggers.</p></li>
        <li><p class="list-item">Multi-Stage Attacks: Often begin with a small, fileless loader (e.g., via a macro or exploit) that then downloads and executes further stages directly in memory, using tools like PowerShell or WMI.</p></li>
    </ul>

    <h3 class="subsection-title">COM Hijacking</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        Component Object Model (COM) is a fundamental Windows technology enabling software components to communicate with each other, regardless of the language they were written in. It relies heavily on the Windows Registry to store information about COM objects, including their unique identifiers (CLSIDs) and the location of the server (often a DLL or EXE) that implements them. COM Hijacking is an evasion and persistence technique where attackers manipulate COM object registrations in the registry to redirect legitimate application calls to malicious code.
    </p>
    <h4 class="subsection-title">Mechanism of Evasion and Persistence</h4>
    <ul>
        <li><p class="list-item">Identifying Target COM Objects: Attackers identify COM objects that are frequently used by legitimate software or the operating system itself.</p></li>
        <li><p class="list-item">Registry Manipulation: They modify specific registry keys related to the target COM object. A common method involves hijacking the <code class="registry-key">InprocServer32</code> key associated with a COM object's CLSID. Instead of pointing to the legitimate DLL server, the attacker modifies this key to point to their malicious DLL.</p></li>
        <li><p class="list-item">Registry Locations: COM registrations are typically found under <code class="registry-key">HKEY_CLASSES_ROOT\CLSID</code> or user-specific locations like <code class="registry-key">HKEY_CURRENT_USER\Software\Classes\CLSID</code>. Hijacking user-specific keys often doesn't require administrative privileges.</p></li>
        <li><p class="list-item">Code Execution: When a legitimate application attempts to instantiate or interact with the hijacked COM object, Windows reads the manipulated registry entry and loads the attacker's malicious DLL into the application's process space instead of, or sometimes alongside, the legitimate one.</p></li>
        <li><p class="list-item">Evasion: Since the execution is triggered by a legitimate application loading what it believes is a legitimate COM server, it can bypass application whitelisting solutions and appear less suspicious in process execution logs compared to running a standalone malicious executable.</p></li>
        <li><p class="list-item">Persistence: If the hijacked COM object is loaded by a process that runs automatically at startup or logon (e.g., <code class="path-example">explorer.exe</code>, scheduled tasks, services), this technique provides a persistent way for the malicious code to execute whenever the trigger process runs.</p></li>
    </ul>

    <h3 class="subsection-title">Shellcode Injection</h3>
    <h4 class="subsection-title">Overview</h4>
    <p class="body-paragraph">
        Shellcode injection is a technique used to execute arbitrary code (shellcode) within the address space of another running process. Shellcode itself is typically a small piece of machine code, often position-independent, designed to perform a specific malicious action, such as opening a reverse shell, downloading and executing a payload, or manipulating the target process. By injecting this code into a legitimate process, attackers aim to evade detection mechanisms focused on file execution and leverage the privileges and network context of the target process.
    </p>
    <h4 class="subsection-title">Mechanism of Evasion</h4>
    <ul>
        <li><p class="list-item">Target Process Selection: The attacker chooses a target process, often a legitimate Windows process (like <code class="path-example">explorer.exe</code>, <code class="path-example">svchost.exe</code>, or a browser process) or a third-party application.</p></li>
        <li><p class="list-item">Process Handle Acquisition: The attacker's code obtains a handle to the target process using APIs like OpenProcess, requesting necessary permissions (e.g., PROCESS_VM_OPERATION, PROCESS_VM_WRITE, PROCESS_CREATE_THREAD).</p></li>
        <li><p class="list-item">Memory Allocation: Memory is allocated within the target process's address space using VirtualAllocEx. This memory region must have execute permissions (PAGE_EXECUTE_READWRITE or similar).</p></li>
        <li><p class="list-item">Shellcode Writing: The malicious shellcode is written into the allocated memory region using WriteProcessMemory.</p></li>
        <li><p class="list-item">Execution Trigger: The attacker needs to trigger the execution of the injected shellcode. Common methods include:</p>
            <ul>
                <li><p class="list-item">Creating a Remote Thread: Using CreateRemoteThread (or undocumented APIs like RtlCreateUserThread) to start a new thread within the target process, with the starting address pointing to the injected shellcode. This is the most classic method.</p></li>
                <li><p class="list-item">Hijacking an Existing Thread: Suspending an existing thread in the target process (SuspendThread), modifying its instruction pointer (SetThreadContext) to point to the shellcode, and then resuming the thread (ResumeThread).</p></li>
                <li><p class="list-item">Asynchronous Procedure Calls (APCs): Queuing an APC (QueueUserAPC) to an existing thread in the target process. When the thread enters an alertable state, the shellcode executes.</p></li>
                <li><p class="list-item">Using SetWindowHookEx or similar callback mechanisms.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Evasion: Since no new executable file is written to disk (unless the shellcode downloads one later), file-based antivirus scanners are bypassed. Running within a legitimate process also helps evade process monitoring and application whitelisting controls. The shellcode itself might be obfuscated or encrypted to avoid memory scanning detection.</p></li>
    </ul>

    <h3 class="subsection-title">Powershell Remoting</h3>
    <p class="body-paragraph">
        Powershell Remoting is a Windows feature designed for administrators to manage systems remotely by executing commands and scripts. However, this capability can be misused during a ScreenShare. An external party with access could potentially connect to the machine undergoing the check and execute commands remotely.
    </p>
    <p class="body-paragraph">
        Misuse Scenario: During a ScreenShare, a remote connection could be used to:
    </p>
    <ul>
        <li><p class="list-item">Delete incriminating files or logs.</p></li>
        <li><p class="list-item">Terminate cheat processes or ScreenSharing tools used by the staffer.</p></li>
        <li><p class="list-item">Modify system settings or registry keys to hide evidence.</p></li>
        <li><p class="list-item">Launch stealthy applications or scripts designed to interfere with the inspection.</p></li>
    </ul>
    <p class="body-paragraph">
        The core issue is the ability to interact with the system under scrutiny externally and potentially unseen by the staffer conducting the ScreenShare locally. Awareness of active remote sessions or unexpected script executions becomes pertinent.
    </p>

    <h3 class="subsection-title">Suspicious DLLs and DLL Injection Techniques</h3>
    <p class="body-paragraph">
        Dynamic Link Libraries (DLLs) are shared libraries containing code and data used by multiple programs. Cheats are often packaged as DLLs because they need to run within the context of the target game process to modify its behavior. Several injection techniques exist to load these malicious DLLs.
    </p>
    <ul>
        <li><p class="list-item">Standard DLL Injection: This is the most common method. An external program (an injector) forces the target process (e.g., Minecraft's <code class="path-example">javaw.exe</code>) to load a specified DLL file from disk. The injector typically uses Windows API functions like CreateRemoteThread and LoadLibrary. While straightforward, it often leaves traces related to file access and process interaction.</p></li>
        <li><p class="list-item">Reflective DLL Injection: A stealthier technique where the DLL is not loaded from disk using standard Windows mechanisms. Instead, the injector writes the raw DLL binary directly into the memory of the target process. A special loader function within the DLL itself then manually performs the tasks usually handled by the Windows loader, such as resolving imports and relocating the code. This avoids using LoadLibrary, making it harder to detect via simple API monitoring, and doesn't require the DLL file to be present on disk at the time of execution, only in memory.</p></li>
        <li><p class="list-item">DLL Hijacking: This technique exploits the way Windows searches for required DLLs when an application starts. If an application needs <code class="path-example">legit.dll</code>, Windows might search several directories in a specific order. An attacker can place a malicious <code class="path-example">legit.dll</code> in a directory that Windows searches before the directory containing the real <code class="path-example">legit.dll</code>. The application then inadvertently loads the malicious version. This relies on replacing or pre-empting legitimate DLLs and can be used for persistence or privilege escalation.</p></li>
        <li><p class="list-item">DLL Proxying: Similar to hijacking, but involves replacing a legitimate DLL with a malicious one that has the same name and exports. The malicious DLL forwards all legitimate function calls to the original DLL (which might be renamed or moved) but also executes its own malicious code. This allows the cheat to run while the application appears to function normally.</p></li>
        <li><p class="list-item">Suspicious DLLs: Beyond injection methods, the characteristics of a DLL itself can be suspicious. Legitimate software DLLs are typically digitally signed by the developer, verifying their authenticity. Cheats or custom-coded DLLs often lack a valid digital signature or may have a broken or untrusted one. While not definitive proof, an unsigned DLL loaded into a game process warrants closer inspection.</p></li>
    </ul>
    <p class="body-paragraph">
        Understanding that DLLs are fundamental to many cheats and that various methods exist to load them (some stealthier than others) is key. The focus shifts from merely finding a file to understanding how it might be loaded and executed within the target process memory.
    </p>

    <h3 class="subsection-title">Process Hollowing</h3>
    <p class="body-paragraph">
        Process Hollowing is an advanced code injection technique where malicious code is hidden inside a legitimate process, making it appear as if only the legitimate process is running.
    </p>
    <p class="body-paragraph">
        Mechanism:
    </p>
    <ol>
        <li><p class="list-item">A legitimate process (e.g., <code class="path-example">explorer.exe</code>, <code class="path-example">svchost.exe</code>) is created in a suspended state.</p></li>
        <li><p class="list-item">The memory allocated to the legitimate code within this suspended process is unmapped (hollowed out).</p></li>
        <li><p class="list-item">Memory is then allocated in the now-empty address space of the legitimate process.</p></li>
        <li><p class="list-item">The malicious code is written into this newly allocated memory region.</p></li>
        <li><p class="list-item">The process's execution context (specifically, the entry point or instruction pointer) is modified to point to the start of the injected malicious code.</p></li>
        <li><p class="list-item">The process is resumed. It now executes the malicious code, but externally it still appears as the legitimate process.</p></li>
    </ol>
    <p class="body-paragraph">
        This technique effectively masks the presence of the malicious code, as standard process listings will only show the name and path of the legitimate host process. Detection often requires analyzing process memory or looking for anomalies in process creation and behavior.
    </p>

    <h3 class="subsection-title">Assembly / .NET Analysis in Complex Bypasses</h3>
    <p class="body-paragraph">
        The .NET Framework is a software development platform from Microsoft used extensively for building Windows applications. It provides a large library of pre-written code (Framework Class Library) and a runtime environment (Common Language Runtime - CLR) to execute applications written in languages like C# or VB.NET.
    </p>
    <p class="body-paragraph">
        Abuse Potential: Because .NET is deeply integrated into Windows and used by countless legitimate applications, attackers leverage it for malicious purposes, often in fileless attacks.
    </p>
    <ul>
        <li><p class="list-item">.NET Assemblies: Malicious code can be compiled into .NET assemblies (DLLs or EXEs). These can be loaded and executed, sometimes directly from memory without touching the disk, using features like System.Reflection.Assembly.Load.</p></li>
        <li><p class="list-item">Leveraging Framework Functions: Attackers can use legitimate .NET functions to perform malicious actions, such as interacting with the OS, managing processes, connecting to networks, or executing further payloads (like PowerShell scripts, since PowerShell itself is built on .NET).</p></li>
        <li><p class="list-item">Metadata Richness: .NET assemblies contain rich metadata, which can sometimes be analyzed to understand their purpose, although obfuscation techniques are often used to hinder this.</p></li>
    </ul>
    <p class="body-paragraph">
        Analyzing processes that host the .NET runtime (<code class="path-example">clr.dll</code>, <code class="path-example">mscoreei.dll</code>) or inspecting loaded .NET assemblies can be crucial in complex bypass scenarios where attackers misuse legitimate framework components. This requires understanding how .NET applications execute and interact with the system.
    </p>

    <h3 class="subsection-title">Environment and Hardware Bypasses</h3>
    <p class="body-paragraph">
        Attackers may manipulate the hardware or operating environment itself to evade detection during ScreenShares.
    </p>

    <h4 class="subsection-title">External USB Drives (FAT32 vs. NTFS):</h4>
    <ul>
        <li><p class="list-item">Cheats can be stored on and executed from external USB drives.</p></li>
        <li><p class="list-item">A key difference lies in the file system used. NTFS (the standard for modern Windows) includes features like the USN Journal, which logs file system changes (creations, deletions, renames). This log can provide evidence of file manipulation even if the file itself is deleted.</p></li>
        <li><p class="list-item">FAT32, commonly used for older or smaller USB drives, lacks journaling. This absence makes it significantly harder to track file operations. A user could potentially delete a cheat file from a FAT32 drive just before or during a ScreenShare, leaving fewer forensic traces compared to an NTFS drive. Awareness of connected storage devices and their file systems is important.</p></li>
    </ul>

    <h4 class="subsection-title">Virtual Machines (VMs):</h4>
    <ul>
        <li><p class="list-item">A VM allows running a separate, isolated operating system inside the main OS.</p></li>
        <li><p class="list-item">Cheats can be run on the host machine while the game runs inside the guest VM. During a ScreenShare conducted within the VM, the staffer has no access to or visibility of the host machine where the cheats might be operating.</p></li>
        <li><p class="list-item">The mere use of a VM during gameplay or ScreenShare is often prohibited by server rules precisely because it hinders effective cheat detection. System information utilities might sometimes reveal if the environment is virtualized.</p></li>
    </ul>

    <h4 class="subsection-title">Cloud Storage (OneDrive, Google Drive, etc.):</h4>
    <ul>
        <li><p class="list-item">Files stored in cloud services like OneDrive are synchronized between the cloud and a local folder on the PC.</p></li>
        <li><p class="list-item">Cheats placed in a synced cloud folder can potentially be manipulated remotely. For instance, a cheat file could be deleted or replaced via another device (like a phone or a second computer) logged into the same cloud account, even while the ScreenShare is in progress on the primary PC. The file might disappear from the local folder with minimal or delayed local logging, depending on the sync client's behavior. Monitoring file activity within known cloud sync directories might be relevant.</p></li>
    </ul>

    <h4 class="subsection-title">Fake Digital Signatures</h4>
    <p class="body-paragraph">
        Digital signatures are used to verify the publisher of a file and ensure its contents haven't been tampered with since it was signed. Trusted software vendors typically sign their executables and DLLs.
    </p>
    <p class="body-paragraph">
        Evasion Technique: Attackers may attempt to bypass security checks or lend false credibility to their malware by:
    </p>
    <ul>
        <li><p class="list-item">Using Stolen Certificates: Obtaining legitimate code-signing certificates illicitly and using them to sign malware.</p></li>
        <li><p class="list-item">Creating Fake Signatures: Generating signatures that might look plausible at a glance but are not issued by a trusted Certificate Authority (CA).</p></li>
        <li><p class="list-item">Self-Signing: Creating a signature using a certificate they generated themselves, which won't be trusted by the operating system.</p></li>
        <li><p class="list-item">Modifying Signed Files: Tampering with a legitimately signed file will invalidate its signature (HashMismatch).</p></li>
    </ul>
    <p class="body-paragraph">
        The presence of a signature is not enough; its validity and the trustworthiness of the issuer must be verified. Tools exist specifically for creating fake signatures, and even legitimate code can be compiled with falsified version information or signatures, especially if source code is available. Verifying the signature chain and checking against known trusted publishers is essential, rather than just observing that a "signature" exists.
    </p>

    <hr>

    <h2 class="section-title">More Artifact Analysis for ScreenSharing</h2>
    <h3 class="subsection-title">$MFT (Master File Table) Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        The Master File Table ($MFT) is the cornerstone of the NTFS file system. It acts as a comprehensive database or index containing metadata records for every file and directory on the volume. Even deleted files often retain their $MFT records for a period, making it a rich source for historical analysis.
    </p>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        Each record in the $MFT holds vital metadata, including:
    </p>
    <ul>
        <li><p class="list-item">File/Directory Names: The name(s) associated with the file or directory.</p></li>
        <li><p class="list-item">Timestamps: Crucial timestamps are stored within specific attributes:</p>
            <ul>
                <li><p class="list-item">$STANDARD_INFORMATION ($SI): Contains the primary set of MAC(b) timestamps (Modified, Accessed, Changed, Birth/Created). These are the timestamps most commonly viewed in Windows Explorer.</p></li>
                <li><p class="list-item">$FILE_NAME ($FN): Contains a separate set of MAC(b) timestamps. Notably, this attribute can sometimes retain timestamp information differently than $SI, especially concerning file creation and modification. Files with long names might have multiple $FN attributes.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Attributes: File attributes like Read-Only, Hidden, System, Compressed, Encrypted.</p></li>
        <li><p class="list-item">Size: The logical and physical size of the file.</p></li>
        <li><p class="list-item">Physical Location: Pointers to the data clusters on the disk where the file's content resides ($DATA attribute).</p></li>
        <li><p class="list-item">Parent Directory: Reference to the MFT record of the parent directory.</p></li>
        <li><p class="list-item">Alternate Data Streams (ADS): Information about any ADS attached to the file.</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        The $MFT provides a detailed timeline of file system activity. By analyzing $MFT records, investigators can:
    </p>
    <ul>
        <li><p class="list-item">Track file creation, deletion, modification, and access times.</p></li>
        <li><p class="list-item">Identify files that may have been deleted but whose records persist.</p></li>
        <li><p class="list-item">Detect Timestomping: Comparing the timestamps within the $SI attribute against those in the $FN attribute(s) can reveal discrepancies indicative of timestamp manipulation. Attackers might alter $SI timestamps, but $FN timestamps are often harder to modify consistently, leaving behind evidence.</p></li>
        <li><p class="list-item">Analyze file attributes for signs of hiding (Hidden attribute) or tampering (Read-Only attribute applied to log files like Prefetch).</p></li>
        <li><p class="list-item">Correlate MFT data with other artifacts like the $UsnJrnl and $LogFile for a more complete picture of file system events.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">MFTECmd (Eric Zimmerman): A command-line tool specifically designed to parse the $MFT. The command <code class="code-block">MFTECmd.exe -f C:\$MFT --csv .</code> exports the $MFT data from drive C: into a CSV file, suitable for analysis in tools like Timeline Explorer.</p></li>
        <li><p class="list-item">FTK Imager: Can be used to extract the $MFT file from a live system or disk image for offline analysis with other tools.</p></li>
        <li><p class="list-item">Search Everything: While not a direct parser, it leverages the MFT (and USN Journal) for its rapid file indexing and can display MFT-derived timestamps.</p></li>
    </ul>

    <h3 class="subsection-title">$LogFile Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        The $LogFile is a critical NTFS metadata file that functions as a transactional log. It records metadata operations before they are fully committed to files like the $MFT. Its primary purpose is system recovery; if the system crashes during an operation, Windows can use the $LogFile to roll back or complete the pending changes, ensuring file system consistency.
    </p>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        $LogFile records operations related to metadata changes, including:
    </p>
    <ul>
        <li><p class="list-item">File creation, deletion, and renaming.</p></li>
        <li><p class="list-item">Timestamp updates ($SI and $FN attributes).</p></li>
        <li><p class="list-item">Attribute changes (e.g., Hidden, Read-Only).</p></li>
        <li><p class="list-item">File size changes.</p></li>
        <li><p class="list-item">Security descriptor modifications.</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        While primarily for system recovery, the $LogFile contains a short-term, highly detailed history of metadata changes.
    </p>
    <ul>
        <li><p class="list-item">Detecting Manipulation: Because it logs intended changes before they hit the $MFT, comparing $LogFile entries with $MFT records and $UsnJrnl events can uncover manipulation attempts like Timestomping or rapid file renaming/deletion meant to obscure activity. For example, it might show the original and the intended modified timestamps during a timestomp operation, providing direct evidence.</p></li>
        <li><p class="list-item">Short-Term Timeline: It offers a granular view of very recent metadata operations, which might be overwritten in the $UsnJrnl or less detailed in the $MFT's timestamps alone.</p></li>
    </ul>

    <h4 class="subsection-title">Challenges and Tools:</h4>
    <ul>
        <li><p class="list-item">Volatility: The $LogFile is circular and overwrites itself relatively quickly, especially on active systems. Evidence might only persist for minutes or hours.</p></li>
        <li><p class="list-item">Parsing Complexity: Parsing the $LogFile is notoriously difficult due to its complex structure and limited public documentation.</p></li>
        <li><p class="list-item">Tools:</p>
            <ul>
                <li><p class="list-item">NTFS Log Parser: Mentioned in the source text as a known tool specifically for parsing the $LogFile, though noted as challenging to use and sparsely documented.</p></li>
                <li><p class="list-item">Other advanced forensic suites might offer partial parsing capabilities.</p></li>
            </ul>
        </li>
    </ul>

    <h3 class="subsection-title">Advanced JumpLists/RecentDocs Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        Jump Lists are a Windows feature designed to provide users quick access to recently opened files, folders, and websites specific to particular applications. RecentDocs refers to the broader tracking of recently accessed items, historically linked to the <code class="path-example">shell:recent</code> folder and associated registry keys.
    </p>

    <h4 class="subsection-title">Artifact Locations:</h4>
    <ul>
        <li><p class="list-item">Jump Lists: Stored as files within the user's profile:</p>
            <ul>
                <li><p class="list-item"><code class="path-example">%APPDATA%\Microsoft\Windows\Recent\AutomaticDestinations\</code> (Stores <code class="file-extension">.automaticDestinations-ms</code> files, system-generated based on application usage).</p></li>
                <li><p class="list-item"><code class="path-example">%APPDATA%\Microsoft\Windows\Recent\CustomDestinations\</code> (Stores <code class="file-extension">.customDestinations-ms</code> files, often populated by application developers or user pinning).</p></li>
            </ul>
        </li>
        <li><p class="list-item">RecentDocs Registry Key: <code class="registry-key">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs</code> (Stores MRU lists, can be cleared by users/cleaning tools).</p></li>
        <li><p class="list-item"><code class="path-example">Shell:Recent</code> Folder: <code class="path-example">C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Recent</code> (Contains <code class="file-extension">.lnk</code> shortcuts to recently accessed files/folders, often reflects RecentDocs registry data).</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        Jump Lists and related artifacts provide valuable insights into user activity:
    </p>
    <ul>
        <li><p class="list-item">File/Folder Access: Show which files and folders a user recently interacted with, often application-specific (e.g., recent Word documents, recent RDP connections).</p></li>
        <li><p class="list-item">Persistence: Jump List files (<code class="file-extension">.automaticDestinations-ms</code>, <code class="file-extension">.customDestinations-ms</code>) often persist even if the RecentDocs registry key or the <code class="path-example">shell:recent</code> folder contents are cleared, providing a more robust history.</p></li>
        <li><p class="list-item">Execution Evidence: Can indicate that a specific application was used to open a particular file.</p></li>
        <li><p class="list-item">Timestamps: Embedded timestamps within the Jump List file structure can help establish timelines.</p></li>
        <li><p class="list-item">Extensionless/Renamed Files: Jump Lists may record interactions with files regardless of their extension, potentially revealing access to disguised executables.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">JumpList Explorer (Eric Zimmerman): A GUI tool for parsing both Automatic and Custom Destinations files.</p></li>
        <li><p class="list-item">LECmd (Eric Zimmerman): A command-line tool (part of the EZ Tools suite) for parsing <code class="file-extension">.lnk</code> files, including those found in the <code class="path-example">shell:recent</code> folder and Jump Lists. Command example: <code class="code-block">LECmd.exe -d "C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Recent" --csv .</code></p></li>
        <li><p class="list-item">Manual Inspection: The <code class="path-example">shell:recent</code> folder can be viewed directly, though the <code class="file-extension">.lnk</code> files need parsing for full details. Registry Editor (regedit) can view the RecentDocs keys.</p></li>
    </ul>

    <h3 class="subsection-title">Amcache/Syscache/RecentFileCache Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        These artifacts are part of the Windows Application Compatibility infrastructure, primarily used to track application execution (not necesserally in instance) and compatibility details.
    </p>

    <h4 class="subsection-title">Artifact Details:</h4>
    <ul>
        <li><p class="list-item">Amcache.hve:</p>
            <ul>
                <li><p class="list-item">Location: <code class="path-example">C:\Windows\AppCompat\Programs\Amcache.hve</code></p></li>
                <li><p class="list-item">OS: Windows 8, 10, 11.</p></li>
                <li><p class="list-item">Content: A registry hive file logging information about executed applications, including executable path, SHA1 hash, first execution time (derived from link file creation time), installation date, and deletion timestamps. It's valuable for proving an application was present and executed at least once, but the timestamps may not always reflect the last execution time accurately.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Syscache.hve:</p>
            <ul>
                <li><p class="list-item">Location: <code class="path-example">C:\Windows\System32\config\System.sav\Syscache.hve</code> (often within System Volume Information, requiring special access).</p></li>
                <li><p class="list-item">OS: Primarily Windows 7 (considered the precursor to Amcache).</p></li>
                <li><p class="list-item">Content: Similar to Amcache, tracks executed programs and drivers. Due to its location, accessing it usually requires mounting the drive offline or using tools that bypass live system locks.</p></li>
            </ul>
        </li>
        <li><p class="list-item">RecentFileCache.bcf:</p>
            <ul>
                <li><p class="list-item">Location: <code class="path-example">C:\Windows\AppCompat\Programs\RecentFileCache.bcf</code></p></li>
                <li><p class="list-item">OS: Windows 7, 8, 10 (presence/utility may vary).</p></li>
                <li><p class="list-item">Content: A binary file format that tracks recently executed files. Can sometimes reveal executions not captured elsewhere or provide more recent execution evidence than Amcache.</p></li>
            </ul>
        </li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        These artifacts help establish that specific programs were executed on a system.
    </p>
    <ul>
        <li><p class="list-item">Proof of Execution: Confirm that an application (e.g., a specific cheat executable) was run.</p></li>
        <li><p class="list-item">Installation/Presence Timeline: Amcache can indicate when a program was first run or potentially installed.</p></li>
        <li><p class="list-item">Identifying Uninstalled/Deleted Programs: Entries may persist even after a program is uninstalled or its executable deleted.</p></li>
        <li><p class="list-item">Hash Correlation: The SHA1 hash in Amcache can be used to identify specific executables even if renamed, by comparing against known malware databases.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">AmcacheParser (Eric Zimmerman): Parses the <code class="path-example">Amcache.hve</code> file. Command-line tool, outputs to CSV.</p></li>
        <li><p class="list-item">Ruedas (SSC Community Tool): Specifically mentioned for parsing <code class="path-example">Syscache.hve</code> on Windows 7 systems, likely requiring the hive to be extracted first (e.g., using FTK Imager).</p></li>
        <li><p class="list-item">RecentFileCacheParser (Eric Zimmerman): Parses the <code class="path-example">RecentFileCache.bcf</code> file. Command-line tool, outputs to CSV. Command example: <code class="code-block">RecentFileCacheParser.exe -f C:\Windows\AppCompat\Programs\RecentFileCache.bcf --csv .</code> (May need to copy the file first if locked).</p></li>
    </ul>

    <h3 class="subsection-title">Activities Cache Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        The Activities Cache (<code class="path-example">ActivitiesCache.db</code>) is an SQLite database that powers the Windows Timeline feature. It logs user activities across different applications and devices, aiming to provide a chronological view of tasks the user was engaged in.
    </p>

    <h4 class="subsection-title">Artifact Location:</h4>
    <ul>
        <li><p class="list-item"><code class="path-example">C:\Users\%username%\AppData\Local\ConnectedDevicesPlatform\&lt;UserProfile&gt;\ActivitiesCache.db</code></p></li>
    </ul>

    <h4 class="subsection-title">Prerequisites:</h4>
    <ul>
        <li><p class="list-item">OS: Windows 10 (Build 1803 and later), Windows 11.</p></li>
        <li><p class="list-item">DiagTrack Service: The "Connected User Experiences and Telemetry" (DiagTrack) service generally needs to be enabled for this database to be actively populated.</p></li>
        <li><p class="list-item">User Settings: User activity history settings must be enabled in Windows privacy settings.</p></li>
        <li><p class="list-item">Encryption: Even if enabled, the database or specific entries might be encrypted, depending on system configuration and version.</p></li>
    </ul>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        The database stores records about various user activities, including:
    </p>
    <ul>
        <li><p class="list-item">Applications launched.</p></li>
        <li><p class="list-item">Files opened (including paths).</p></li>
        <li><p class="list-item">Websites visited (browser-dependent).</p></li>
        <li><p class="list-item">Timestamps (start and end times of activities).</p></li>
        <li><p class="list-item">Device information (if synced across devices).</p></li>
        <li><p class="list-item">Application-specific details (e.g., document name, window title).</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        Provides a user-centric timeline of interactions with applications and files.
    </p>
    <ul>
        <li><p class="list-item">Execution Confirmation: Can corroborate evidence of application usage found in other artifacts.</p></li>
        <li><p class="list-item">File Access History: Shows which specific files were opened by which applications.</p></li>
        <li><p class="list-item">Contextual Timeline: Helps reconstruct what the user was doing around specific times.</p></li>
        <li><p class="list-item">Potential for Deleted File Evidence: May contain references to files that have since been deleted.</p></li>
    </ul>

    <h4 class="subsection-title">Challenges and Tools:</h4>
    <ul>
        <li><p class="list-item">Dependency on Settings: Relies heavily on OS and user privacy settings being enabled.</p></li>
        <li><p class="list-item">Encryption: Can be encrypted, making direct parsing difficult without appropriate tools or system access.</p></li>
        <li><p class="list-item">Privacy Concerns: Contains detailed user activity, requiring careful handling. Direct registry parsing of related keys (CloudStore...) is discouraged due to potential exposure of sensitive information like emails.</p></li>
        <li><p class="list-item">Tools:</p>
            <ul>
                <li><p class="list-item">WxTCmd (Eric Zimmerman): The recommended command-line tool for parsing the <code class="path-example">ActivitiesCache.db</code>. It handles potential encryption and structures the output (e.g., into CSV) for easier analysis, mitigating privacy risks associated with manual registry exploration.</p></li>
                <li><p class="list-item">SQLite Browsers: Can be used to view the database structure if it's not encrypted, but WxTCmd is generally preferred for forensic soundness.</p></li>
            </ul>
        </li>
    </ul>

    <h3 class="subsection-title">SRUM (System Resource Usage Monitor) Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        The System Resource Usage Monitor (SRUM) utilizes the <code class="path-example">SRUDB.dat</code> ESE database to monitor and log detailed resource usage metrics for processes and network connections on Windows systems (Windows 8 and later). It tracks background and foreground activity, network data usage, and more over a period (typically ~30-60 days).
    </p>

    <h4 class="subsection-title">Artifact Location:</h4>
    <ul>
        <li><p class="list-item"><code class="path-example">C:\Windows\System32\sru\SRUDB.dat</code></p></li>
    </ul>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        SRUM tracks a wealth of information, including:
    </p>
    <ul>
        <li><p class="list-item">Process Execution: Records processes that have run, including executable name and path.</p></li>
        <li><p class="list-item">User Context: Associates activity with specific user SIDs.</p></li>
        <li><p class="list-item">Timestamps: Logs when processes were active.</p></li>
        <li><p class="list-item">Resource Consumption: Tracks CPU time (foreground/background), disk I/O (reads/writes).</p></li>
        <li><p class="list-item">Network Activity: Monitors network data sent/received per application and interface, network connectivity duration.</p></li>
        <li><p class="list-item">Push Notifications: Records application push notifications, including the app ID and timestamp.</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        SRUM is often called a "forensic goldmine" because it provides:
    </p>
    <ul>
        <li><p class="list-item">Long-Term Execution History: Can show evidence of program execution over the last 30-60 days, often persisting longer than Prefetch or BAM for specific instances.</p></li>
        <li><p class="list-item">Network Data Usage: Helps identify applications communicating over the network, potentially revealing C2 communication or data exfiltration, including bytes sent/received.</p></li>
        <li><p class="list-item">User Attribution: Links resource usage directly to specific users.</p></li>
        <li><p class="list-item">Identifying Background Activity: Tracks processes running without direct user interaction.</p></li>
        <li><p class="list-item">Push Notification Evidence: The PushNotifications table can sometimes link activity to specific applications (e.g., cheat launchers using notifications) identified by their AppID and User ID.</p></li>
        <li><p class="list-item">Application Uptime: The AppTimelineProvider data shows application focus time (Foreground Time), potentially useful for correlating with user activity.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">SrumECmd (Eric Zimmerman): The standard command-line tool for parsing the <code class="path-example">SRUDB.dat</code> database. It exports various tables into CSV format for analysis. Command example: <code class="code-block">SrumECmd.exe -d C:\Windows\System32\sru --csv .</code></p></li>
        <li><p class="list-item">Timeline Explorer: Used to analyze the CSV output from SrumECmd, allowing filtering and sorting by time, user, application, etc.</p></li>
        <li><p class="list-item">Epoch Converters: Timestamps within SRUM (like Foreground Time) might be in Epoch format and require conversion to human-readable dates/times.</p></li>
    </ul>

    <h3 class="subsection-title">Volume Shadow Copies (VSS) Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        Volume Shadow Copies (VSS), also known as Volume Snapshots, are point-in-time copies of disk volumes created by Windows. They are primarily used by features like System Restore and Previous Versions to allow users or administrators to revert files or the system state to an earlier point in time.
    </p>

    <h4 class="subsection-title">How They Work:</h4>
    <p class="body-paragraph">
        VSS works by tracking changes to disk blocks. When a snapshot is created, the system essentially freezes the state of the blocks at that moment. As changes occur on the live volume, the original data from the modified blocks is copied to a designated storage area before being overwritten. This allows the system to reconstruct the volume as it existed when the snapshot was taken.
    </p>

    <h4 class="subsection-title">Artifact Location:</h4>
    <p class="body-paragraph">
        Shadow Copies are stored in the System Volume Information folder on the root of the NTFS volume, typically hidden and protected. They are not directly accessible like regular files but can be mounted or accessed using specific tools or APIs.
    </p>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        VSS holds significant forensic value because snapshots may contain:
    </p>
    <ul>
        <li><p class="list-item">Deleted Files: Files that were present when the snapshot was created but have since been deleted from the live file system might still exist within the shadow copy. This is particularly useful for recovering deleted scripts, configuration files, or even small executables.</p></li>
        <li><p class="list-item">Previous Versions of Files: Older versions of log files, registry hives, databases ($MFT, $UsnJrnl, $LogFile), or other artifacts can be extracted from VSS. This allows comparison with the live system to detect tampering, deletion of entries, or to extend the historical timeline beyond what's available on the live system.</p></li>
        <li><p class="list-item">Evidence Persistence: If an attacker or user attempts to clear tracks by deleting files or logs, older shadow copies might still retain the evidence.</p></li>
    </ul>

    <h4 class="subsection-title">Challenges:</h4>
    <ul>
        <li><p class="list-item">Configuration Dependent: VSS must be enabled on the volume (it often is by default for the system drive C:).</p></li>
        <li><p class="list-item">Space Management: Windows automatically manages VSS storage space. Older snapshots are deleted as new ones are created or as disk space limits are reached. Evidence may not persist indefinitely.</p></li>
        <li><p class="list-item">User Deletion: Users with administrative privileges can manually delete shadow copies or disable VSS.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item"><code class="code-block">vssadmin</code> (Built-in Windows command): Can list existing shadow copies (<code class="code-block">vssadmin list shadows</code>).</p></li>
        <li><p class="list-item">ShadowExplorer: A GUI tool that allows browsing the contents of shadow copies like regular folders.</p></li>
        <li><p class="list-item">OSForensics: Contains a feature to find and mount shadow copies for analysis within its case environment.</p></li>
        <li><p class="list-item">Eric Zimmerman's Tools (RECmd, MFTECmd, etc.): Many of Zimmerman's tools include a <code class="code-block">--vss</code> command-line switch that automatically processes all available shadow copies on the target drive, integrating data from snapshots directly into the analysis output (e.g., finding registry keys or MFT entries from older points in time). This is highly efficient for timeline reconstruction.</p></li>
        <li><p class="list-item">FTK Imager: Can be used to mount disk images containing shadow copies for examination.</p></li>
    </ul>

    <h3 class="subsection-title">$INDX ($i30 Index Attributes) Analysis</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <p class="body-paragraph">
        In NTFS, directories are stored using special index attributes, primarily $INDEX_ROOT and $INDEX_ALLOCATION. The most common index, often referred to by its attribute type identifier $i30 in forensic tools, lists the files and subdirectories contained within a directory. It essentially stores the directory's content listing.
    </p>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        Each entry within a directory's $i30 index contains metadata about a file or subdirectory within it, derived from that item's $MFT $FILE_NAME attribute, including:
    </p>
    <ul>
        <li><p class="list-item">File/Directory Name.</p></li>
        <li><p class="list-item">MFT File Reference Number of the item.</p></li>
        <li><p class="list-item">Timestamps (Created, Modified, Accessed, MFT Entry Changed - mirroring the $FN timestamps).</p></li>
        <li><p class="list-item">File Size.</p></li>
        <li><p class="list-item">File Attributes (Hidden, Read-Only, etc.).</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        Analyzing $i30 index attributes, especially including slack space, can yield evidence not easily found elsewhere:
    </p>
    <ul>
        <li><p class="list-item">Deleted File Metadata: When files are deleted, their entries in the parent directory's $i30 index are marked as unused but are often not immediately overwritten. Forensic tools can carve these inactive entries from the index B-tree structure and its slack space, recovering metadata (name, timestamps, size) of files that no longer have active $MFT records. This can prove a file existed in a specific directory at some point.</p></li>
        <li><p class="list-item">Timeline Reconstruction: Timestamps within $i30 entries reflect the file's $FN timestamps and can help build timelines of file activity within specific directories.</p></li>
        <li><p class="list-item">Corroboration: Can corroborate findings from $MFT and $UsnJrnl analysis regarding file existence and timestamps within a directory context.</p></li>
    </ul>

    <h4 class="subsection-title">Slack Space:</h4>
    <p class="body-paragraph">
        Index attributes, like files, have allocated space. When entries are deleted or directory contents change, the previously used space within the $INDEX_ALLOCATION attribute might not be fully zeroed out, leaving remnants of old directory entries in this "slack space". Carving this space is crucial for recovering information about deleted items.
    </p>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">INDXRipper: Explicitly mentioned in the source text for carving metadata from NTFS $i30 indexes. It parses the $INDEX_ALLOCATION attribute, including slack space, to recover metadata for both active and deleted directory entries. The command <code class="code-block">INDXRipper.exe //./C: --deleted-dirs output.csv</code> targets drive C:, focuses on deleted entries, and outputs to a CSV file suitable for Timeline Explorer.</p></li>
        <li><p class="list-item">MFTECmd (with specific options): While primarily an MFT parser, MFTECmd might extract some index-related information depending on the options used.</p></li>
        <li><p class="list-item">Advanced Forensic Suites (e.g., EnCase, Axiom): Often include capabilities to parse NTFS index attributes and carve deleted entries.</p></li>
    </ul>

    <h3 class="subsection-title">Process and Memory Dump Analysis (Kernel Live Dump, RAM Dump)</h3>

    <h4 class="subsection-title">Definition and Purpose:</h4>
    <ul>
        <li><p class="list-item">RAM Dump (Physical Memory Dump): A complete copy of the contents of the system's volatile physical memory (RAM) at a specific moment in time. It captures the state of all running processes, loaded drivers, network connections, kernel structures, user activities, and potentially sensitive data like passwords or encryption keys present in memory.</p></li>
        <li><p class="list-item">Kernel Live Dump: A more targeted memory dump focusing primarily on the Windows kernel memory space, often including process metadata but potentially less user-mode application data than a full RAM dump. It can be created without necessarily crashing or pausing the system entirely and is useful for diagnosing kernel-level issues (like crashes or hangs) but also valuable for forensic analysis of kernel-mode malware or rootkits. The source text implies its utility in finding command-line history.</p></li>
    </ul>

    <h4 class="subsection-title">Information Contained:</h4>
    <p class="body-paragraph">
        Memory dumps contain a wealth of volatile information:
    </p>
    <ul>
        <li><p class="list-item">Running processes and threads.</p></li>
        <li><p class="list-item">Loaded DLLs and drivers.</p></li>
        <li><p class="list-item">Network connections (sockets, ports, associated processes).</p></li>
        <li><p class="list-item">Open file handles.</p></li>
        <li><p class="list-item">Registry keys loaded into memory.</p></li>
        <li><p class="list-item">Command-line history for executed processes.</p></li>
        <li><p class="list-item">Clipboard contents.</p></li>
        <li><p class="list-item">User credentials (potentially hashed or in plaintext).</p></li>
        <li><p class="list-item">Injected code or unpacked malware.</p></li>
        <li><p class="list-item">Kernel data structures.</p></li>
    </ul>

    <h4 class="subsection-title">Forensic Significance:</h4>
    <p class="body-paragraph">
        Memory analysis is crucial for detecting threats and activities that leave minimal disk footprint:
    </p>
    <ul>
        <li><p class="list-item">Fileless Malware: Malware that resides only in memory can be identified.</p></li>
        <li><p class="list-item">Injected Code: Detecting code injected into legitimate processes (e.g., DLL injection, process hollowing).</p></li>
        <li><p class="list-item">Command History Recovery: As highlighted in the source text for Kernel Live Dumps, analyzing memory can reveal the command lines used to launch processes, even for short-lived <code class="path-example">cmd.exe</code> or <code class="path-example">powershell.exe</code> windows. Tools like <code class="path-example">strings64.exe</code> combined with <code class="path-example">findstr</code> can search the dump for specific commands (e.g., <code class="code-block">java -jar</code>, <code class="code-block">rundll32.exe</code>, <code class="code-block">wmic</code>, <code class="code-block">regsvr32</code>, powershell scripts).</p></li>
        <li><p class="list-item">Network Activity: Identifying malicious network connections.</p></li>
        <li><p class="list-item">Credentials Theft: Potentially recovering passwords or tokens.</p></li>
        <li><p class="list-item">Rootkit Detection: Finding hidden processes or drivers.</p></li>
    </ul>

    <h4 class="subsection-title">Challenges for ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">Complexity: Memory analysis requires specialized knowledge and tools.</p></li>
        <li><p class="list-item">Volatility: Data changes rapidly; the dump is only a snapshot.</p></li>
        <li><p class="list-item">Size: Full RAM dumps can be very large (gigabytes).</p></li>
        <li><p class="list-item">Intrusiveness & Ethics: Acquiring a memory dump is an intrusive process. Analyzing it requires careful handling due to potentially sensitive user data. Its use in typical ScreenSharing scenarios is generally discouraged due to complexity and ethical/privacy risks unless absolutely necessary and performed by trained individuals.</p></li>
    </ul>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">Acquisition:</p>
            <ul>
                <li><p class="list-item">FTK Imager: Can capture a live RAM dump.</p></li>
                <li><p class="list-item">DumpIt (Comae): A simple command-line tool for creating RAM dumps.</p></li>
                <li><p class="list-item">Magnet RAM Capture: Free tool from Magnet Forensics for RAM acquisition.</p></li>
                <li><p class="list-item">System Informer: Can create Kernel Live Dumps.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Analysis:</p>
            <ul>
                <li><p class="list-item">Volatility Framework / Volatility Workbench: The industry standard open-source framework for analyzing memory dumps (Windows, Linux, macOS). Requires profiles matching the OS version.</p></li>
                <li><p class="list-item">MemProcFS: A tool that mounts memory dumps as a virtual file system, allowing easier browsing and analysis with standard file system tools.</p></li>
                <li><p class="list-item">Strings Utilities (<code class="path-example">strings64.exe</code>, <code class="path-example">bstrings.exe</code>): Can extract readable strings from memory dumps, useful for quick keyword searches (like finding commands). The command <code class="code-block">strings64.exe -accepteula -s -n 4 KERNELDUMP.dmp | findstr "specific_command"</code> searches a dump file for a specific command string.</p></li>
                <li><p class="list-item">Windbg: Microsoft's debugger, can be used for deep analysis of kernel dumps.</p></li>
                <li><p class="list-item">Redline (FireEye/Mandiant): Free tool offering automated memory analysis features.</p></li>
            </ul>
        </li>
    </ul>

    <h3 class="subsection-title">YARA Rules</h3>
    <p class="body-paragraph">
        YARA is a tool primarily utilized for identifying and classifying malware samples based on specific patterns. It operates by defining rules, which consist of sets of strings (textual or hexadecimal patterns) and a boolean expression determining the rule's logic. When a file or memory region matches the defined strings and satisfies the boolean condition, YARA reports it according to the rule's identifier.
    </p>

    <h4 class="subsection-title">Key Features and Usage in ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">Pattern Matching: YARA excels at searching for specific textual or binary sequences within files or process memory. This is useful for finding known cheat strings, unique code snippets, or metadata associated with malicious tools.</p></li>
        <li><p class="list-item">Rule Creation: Users can create custom YARA rules to detect specific cheats or bypass techniques. This involves extracting unique identifiers (strings, imports, entropy values) from known malicious files (using tools like HxD or Detect It Easy) and defining conditions for a match. For example, rules can be crafted to detect files requiring administrator privileges (<code class="code-block">level="requireAdministrator"</code>) or specific combinations of imported modules and internal strings (as shown in the MrKaplan example rules).</p></li>
        <li><p class="list-item">Integration: YARA can be integrated with other forensic tools like Velociraptor, allowing for targeted scans within specific processes or across entire file systems based on custom rules. SS Tools like Ocean and Golden have also implemented YARA for detection purposes.</p></li>
        <li><p class="list-item">Command-Line Interface: YARA typically operates via the command line, offering various options to specify rules files, target files/directories/processes (PIDs), and control output details (e.g., printing matching strings, metadata, tags).</p></li>
        <li><p class="list-item">Flexibility: It supports wild-cards, case-insensitive strings, regular expressions, and special operators, enabling the creation of powerful and adaptable detection rules.</p></li>
        <li><p class="list-item">Hinting at Detection: YARA serves as a powerful hunting tool. By defining rules based on the characteristics of known cheats (specific strings, code patterns, metadata), ScreenSharers can use YARA to scan files or memory for matches, thereby identifying potential instances of those cheats or related tools.</p></li>
    </ul>

    <h3 class="subsection-title">File Entropy Analysis</h3>
    <p class="body-paragraph">
        File entropy is a measure of the randomness or disorder within a file's data. In the context of file analysis during ScreenSharing, entropy values are often used as an indicator of whether a file has been packed, encrypted, or obfuscated.
    </p>

    <h4 class="subsection-title">Key Concepts:</h4>
    <ul>
        <li><p class="list-item">Packed/Encrypted Files: Malicious software, including cheats, is often packed or encrypted to hide its true code and evade signature-based detection. These processes tend to increase the randomness of the data within the file.</p></li>
        <li><p class="list-item">High Entropy: A high entropy value typically suggests a high degree of randomness, which is characteristic of compressed, encrypted, or packed data. Legitimate executable files usually have a mix of structured code and data, resulting in lower entropy compared to packed files.</p></li>
        <li><p class="list-item">Suspicion Indicator: While not definitive proof of malice on its own, a high file entropy value (e.g., above a certain threshold like 6, as used by Rancio's Anti-Scheduler tool) is considered a suspicious indicator. It suggests the file might be obfuscated or packed, warranting further investigation.</p></li>
        <li><p class="list-item">Analysis Tools: Tools like Detect It Easy (DiE) and VirusTotal can calculate and display a file's entropy. This information, combined with other factors like digital signatures and known patterns, helps assess the likelihood of a file being malicious.</p></li>
        <li><p class="list-item">Hinting at Detection: Analyzing a file's entropy helps identify potentially obfuscated or packed executables. High entropy serves as a red flag, prompting the ScreenSharer to apply other analysis techniques to determine if the packed file is indeed a cheat or other malicious software.</p></li>
    </ul>

    <h3 class="subsection-title">Detect It Easy (DiE)</h3>
    <p class="body-paragraph">
        Detect It Easy (DiE) is a utility designed for analyzing the structure and characteristics of executable files, particularly Portable Executable (PE) files like <code class="file-extension">.exe</code> and <code class="file-extension">.dll</code>. It helps in understanding how a file is built and what components it contains.
    </p>

    <h4 class="subsection-title">Key Features and Usage in ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">PE File Analysis: DiE allows examination of various aspects of PE files, including headers, sections, imports (functions borrowed from other DLLs), exports (functions provided by the DLL), and resources.</p></li>
        <li><p class="list-item">String Extraction: It can extract embedded strings (ASCII and Unicode) from a file, which might contain useful clues like developer comments, internal function names, configuration data, or even cheat-related keywords.</p></li>
        <li><p class="list-item">Entropy Calculation: DiE calculates the entropy of the file and its sections, helping to identify potentially packed or encrypted data (as discussed under File Entropy Analysis).</p></li>
        <li><p class="list-item">Packer/Protector Detection: It includes signatures to detect common packers, protectors, or compilers used to create the executable, which can indicate attempts to obfuscate the code.</p></li>
        <li><p class="list-item">Dependency Analysis: By examining the import table, DiE reveals which DLLs the file depends on and which functions it uses, which can sometimes indicate suspicious behavior (e.g., importing functions related to process injection or hooking).</p></li>
        <li><p class="list-item">Troubleshooting Execution: As mentioned in the provided text (Example G), if a suspicious file fails to execute or closes immediately (especially if it seems related to ScreenSharing software like AnyDesk being active), DiE can be used to analyze its structure and embedded information without running it, potentially revealing its purpose or malicious nature.</p></li>
        <li><p class="list-item">Hinting at Detection: DiE is an analytical tool used to dissect executable files. By revealing a file's internal structure, dependencies, embedded strings, and entropy, it helps ScreenSharers identify suspicious characteristics or confirm if a non-executing file matches known cheat profiles.</p></li>
    </ul>

    <h3 class="subsection-title">Velociraptor</h3>
    <p class="body-paragraph">
        Velociraptor is a powerful, advanced open-source tool designed for Digital Forensics and Incident Response (DFIR). It operates on a client-server model (though it can be run locally via its GUI) and uses its own Velociraptor Query Language (VQL) to collect and analyze artifacts from endpoints.
    </p>

    <h4 class="subsection-title">Key Features and Usage in ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">Artifact Collection: Velociraptor can collect a wide array of digital evidence from Windows, Linux, and macOS endpoints, including file system data, registry entries, event logs, process information, memory artifacts, and network connections.</p></li>
        <li><p class="list-item">NTFS Analysis: It includes specific capabilities ("NTFS parsers") to analyze low-level NTFS structures like the Master File Table ($MFT), the USN Journal ($J), $LogFile, Index Attributes ($I30), Alternate Data Streams (ADS), and Extended Attributes. This allows for deep file system analysis, uncovering file creation/deletion/modification timelines, hidden data streams, and tampering evidence.</p></li>
        <li><p class="list-item">Live System Analysis ("Hunt"): Unlike tools that only work on disk images, Velociraptor excels at querying the live, volatile state of a running system. It can inspect running processes, open files, network sockets, and volatile memory artifacts that disappear upon shutdown.</p></li>
        <li><p class="list-item">YARA Integration: Velociraptor can execute YARA rules directly against files on disk or within process memory. This allows for flexible, signature-based hunting for malware or cheats based on custom rules (as demonstrated by the example script searching for "this is a test" in notepad.exe memory).</p></li>
        <li><p class="list-item">Memory Evasion Detection: Through custom VQL scripts, often developed by the DFIR community, Velociraptor can hunt for indicators of memory evasion techniques like shellcode injection or reflective DLL loading within active processes.</p></li>
        <li><p class="list-item">Scalability: While powerful for single-host analysis during a ScreenShare, its core design allows for querying hundreds or thousands of endpoints simultaneously in an enterprise environment.</p></li>
        <li><p class="list-item">Installation: Recent versions offer an <code class="file-extension">.msi</code> installer for easier deployment on Windows, though it might require specific Access Control List (ACL) configurations. The command-line version can be launched with a GUI using the <code class="code-block">gui</code> argument.</p></li>
        <li><p class="list-item">Hinting at Detection: Velociraptor provides advanced artifact collection and hunting capabilities. It enables ScreenSharers to perform deep file system analysis (NTFS artifacts), scan live memory with YARA rules, and investigate volatile system states to uncover sophisticated cheats, bypasses, or memory evasion techniques that simpler tools might miss.</p></li>
    </ul>

    <h3 class="subsection-title">Magnet EDD (Encrypted Disk Detector)</h3>
    <p class="body-paragraph">
        Magnet EDD is a specialized tool from Magnet Forensics designed specifically to detect the presence of encrypted volumes on a system.
    </p>

    <h4 class="subsection-title">Key Features and Usage in ScreenSharing:</h4>
    <ul>
        <li><p class="list-item">Detection Scope: It scans for various types of full-disk or partition encryption, including common solutions like BitLocker (Windows native), TrueCrypt (legacy but still encountered), VeraCrypt (popular open-source successor to TrueCrypt), and potentially others.</p></li>
        <li><p class="list-item">Supported File Systems: The tool is capable of scanning drives formatted with NTFS, exFAT, and FAT32 file systems.</p></li>
        <li><p class="list-item">Operation: It's typically run as a simple executable, often via an administrative command prompt using a <code class="code-block">/batch</code> switch for automated scanning.</p></li>
        <li><p class="list-item">Purpose in ScreenSharing: The primary goal is to identify if the user has encrypted drives or partitions. Encrypted volumes can be used to hide files, including cheats, tools, or incriminating data, making them inaccessible during a standard ScreenShare unless the user provides the password or key.</p></li>
        <li><p class="list-item">Hinting at Detection: Magnet EDD doesn't detect cheats directly but identifies potential hiding places. Discovering an active, encrypted volume during a ScreenShare raises suspicion, as it represents an area inaccessible to the ScreenSharer where malicious files could be stored.</p></li>
    </ul>

    <h3 class="subsection-title">Rancio's Tools</h3>
    <p class="body-paragraph">
        This refers to a collection of specific, often standalone tools developed by Rancio (a prominent figure in the ScreenShare community, now associated with Ocean SS Tool) to address particular detection needs during ScreenShares.
    </p>

    <h4 class="subsection-title">Tools:</h4>
    <ul>
        <li><p class="list-item">DoomsDay Client Finder (<code class="path-example">DDFO.exe</code>): A targeted tool designed to detect the presence of the "DoomsDay" Minecraft cheat client internally. The provided text notes it was tested specifically on version 1.16.5.</p></li>
        <li><p class="list-item">Unicode Detector (<code class="path-example">Unicode.exe</code>): This tool focuses on finding files that use Unicode characters in their names, particularly targeting suspicious file types like executables and DLLs. Unicode characters can be used to disguise file names or bypass simple string-matching detections.</p></li>
        <li><p class="list-item">Ocean SS Tool: While a full SS Tool, it's linked to Rancio and mentioned as the free successor to the Golden SS Tool. It's a comprehensive scanner for Minecraft (free) and other games (paid), featuring a web dashboard, pin system for initiating scans, integration with VirusTotal/Hybrid Analysis, detection of various cheats and bypass methods (including Task Scheduler, VMs), and detailed scan result reporting (logs, process times, etc.). It's noted for being particularly adept at detecting bypass methods.</p></li>
        <li><p class="list-item">GlobalLister: A utility that queries the system's DeviceID, likely against an online database, to retrieve the original product name and specifications of hardware components. This could potentially help identify spoofed or unusual hardware.</p></li>
        <li><p class="list-item">Maceta (<code class="path-example">maceta.exe</code>): This tool leverages the VirusTotal API to specifically check unsigned executable files for maliciousness. It requires a VirusTotal API key and is often used in conjunction with a dump of process strings (like from <code class="path-example">csrss.exe</code>) to identify and verify suspicious unsigned executables found in memory.</p></li>
        <li><p class="list-item">Hinting at Detection: Each of Rancio's tools provides a focused capability for detection: DDFO targets a specific cheat, Unicode Detector finds suspiciously named files, Ocean offers broad cheat and bypass scanning, GlobalLister verifies hardware identity, and Maceta uses external intelligence (VirusTotal) to verify unsigned executables.</p></li>
    </ul>

    <h3 class="subsection-title">Echo's Tools</h3>
    <p class="body-paragraph">
        This refers to a suite of free, standalone utilities provided by the Echo SS Tool team, designed to assist with specific manual analysis tasks during a ScreenShare, complementing their main automated scanner.
    </p>

    <h4 class="subsection-title">Tools Mentioned:</h4>
    <ul>
        <li><p class="list-item">Echo BAM (<code class="path-example">bam.exe</code>): A graphical tool to view, filter, and reorder entries from the Background Activity Moderator (BAM) registry keys. It simplifies accessing BAM data, which logs program executions (primarily <code class="file-extension">.exe</code> files).</p></li>
        <li><p class="list-item">Echo Journal Tool (<code class="path-example">journal-tool.exe</code>): A parser for the NTFS USN Journal ($J). It allows filtering for specific events like file deletions, creations, and renames. It's presented as a user-friendly alternative to using <code class="code-block">fsutil</code> commands and is noted for parsing all NTFS drives simultaneously.</p></li>
        <li><p class="list-item">Echo UserAssist View (<code class="path-example">userassist.exe</code>): A viewer for Windows UserAssist registry data. UserAssist tracks the execution of GUI applications. This tool reportedly shows if the target file still exists and allows quick navigation to it.</p></li>
        <li><p class="list-item">Echo String Tool (<code class="path-example">strings-tool.exe</code>): Allows searching for multiple specific strings within a selected process's memory simultaneously. It's useful for quickly testing custom string detections or looking for known cheat indicators without needing to repeatedly use tools like System Informer's string search.</p></li>
        <li><p class="list-item">Echo USBDEVIEW: A tool similar to Nirsoft's USBDeview, designed to show the history of USB devices connected to the PC. It displays information like the last plug-in and unplug times and the type of USB device, aiming for a less cluttered interface than the original Nirsoft tool.</p></li>
        <li><p class="list-item">Hinting at Detection: These tools facilitate manual artifact analysis. They provide user-friendly interfaces to access and filter data from key Windows artifacts (BAM, USN Journal, UserAssist, USB History) or perform targeted searches (String Tool), aiding the ScreenSharer in finding evidence of cheat execution or related suspicious activity.</p></li>
    </ul>

    <h3 class="subsection-title">Specific PowerShell Scripts</h3>
    <p class="body-paragraph">
        PowerShell scripts are extensively used in the provided text for automating various tasks related to ScreenSharing and digital forensics analysis. They act as custom tools to gather, parse, and analyze data from the system quickly.
    </p>

    <h4 class="subsection-title">Key Categories and Examples:</h4>
    <ul>
        <li><p class="list-item">Signature and Integrity Checks:</p>
            <ul>
                <li><p class="list-item">RL Signature Check (<code class="path-example">RedLotusSignatures.ps1</code>): Takes a list of file paths (often from a <code class="path-example">paths.txt</code> file generated by dumping process strings) and checks the Authenticode digital signature status of each file (Valid, NotSigned, HashMismatch, NotTrusted, UnknownError, or NotFound). Crucial for identifying unsigned or tampered executables/DLLs.</p></li>
                <li><p class="list-item">Prefetch Integrity Analyzer (<code class="path-example">RedLotusPrefetchIntegrityAnalyzer.ps1</code>): Scans the <code class="path-example">C:\Windows\Prefetch</code> directory for anomalies. It checks if files are read-only, if they have the correct "MAM" header, and identifies files with duplicate hashes (potentially indicating type or echo command manipulation).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Artifact Parsing and Data Extraction:</p>
            <ul>
                <li><p class="list-item">RL BAM Script (<code class="path-example">RedLotusBam.ps1</code>): Parses BAM registry keys, displays execution timestamps (UTC, User TimeZone), application path, attempts to resolve the user SID, and crucially, also performs a signature check (using the Get-Signature function) on the executable path, reporting its status or if the file was not found.</p></li>
                <li><p class="list-item">Streams Script (<code class="path-example">Streams.ps1</code>): Scans a specified folder (optionally recursively) for files, retrieving details like path, name, hash (MD5), owner, timestamps, attributes, and importantly, lists Alternate Data Streams (ADS) including Zone.Identifier content. Helps find hidden data or trace file origins.</p></li>
                <li><p class="list-item">ActivitiesCache Parser (<code class="path-example">ActivitiesCache.ps1</code>): Downloads and runs a dedicated <code class="file-extension">.exe</code> parser (<code class="path-example">ActivitiesCacheParser.exe</code>) to extract and format data from the <code class="path-example">ActivitiesCache.db</code>, filtering by the oldest logon time.</p></li>
                <li><p class="list-item">Task Scheduler Parsers:</p>
                    <ul>
                        <li><p class="list-item"><code class="path-example">ManualTasks.ps1</code>: Lists scheduled tasks created specifically by the current user.</p></li>
                        <li><p class="list-item"><code class="path-example">SuspiciousScheduler.ps1</code>: Lists scheduled tasks and flags actions involving potentially suspicious programs often used in bypasses (cmd, powershell, rundll32, etc.).</p></li>
                        <li><p class="list-item"><code class="path-example">Task-Scheduler-Parser/script.ps1</code> (Rio/ObsessiveBf): Parses XML task files in <code class="path-example">C:\Windows\System32\Tasks</code>, extracts commands and arguments, saves them to text files, and flags tasks containing suspicious keywords.</p></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><p class="list-item">Information Gathering:</p>
            <ul>
                <li><p class="list-item">MiniSS Script (<code class="path-example">miniss.ps1</code>): A general-purpose script (content not fully detailed, but likely gathers basic system info, recent files, etc.).</p></li>
                <li><p class="list-item">HardDiskVolume Converter (<code class="path-example">RedLotusHardDiskVolumeConverter.ps1</code>): Takes a list of paths starting with <code class="path-example">\Device\HarddiskVolumeX</code> (often found in DPS logs) from a <code class="path-example">paths.txt</code> file and converts them to standard drive letter paths (e.g., <code class="path-example">C:\...</code>).</p></li>
                <li><p class="list-item">Event Log Script (<code class="path-example">RLUEvents.csv</code> script): Queries specified Windows Event Logs (Application, System, Security, PowerShell, etc.) for a predefined list of critical Event IDs (e.g., 3079 for Journal deletion, 1102 for Log clearing, 4616 for time change, 7036 for service stop/start) and exports the newest findings to a CSV file.</p></li>
                <li><p class="list-item"><code class="path-example">DFIR-Collect-W10.ps1</code>: A comprehensive script collecting a wide range of system information (OS info, users, network config, services, processes, scheduled tasks, hotfixes, installed apps, DNS cache, optionally Registry, MFT, Event Logs) and exporting it primarily into XML (then converting to CSV/TXT).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Utility Scripts:</p>
            <ul>
                <li><p class="list-item">PowerShell WinPrefetchView (<code class="path-example">WinPrefetch_Powershell.ps1</code>): Automates the download and execution of Nirsoft's WinPrefetchView, potentially allowing filtering by date.</p></li>
                <li><p class="list-item">Alt Finders (<code class="path-example">WatsonAltChecker.ps1</code>, <code class="path-example">message.txt</code> script): Search user directories and log files for specific strings (like "user", "username", or custom terms) to find evidence of alternate accounts.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Execution Policy: Many scripts require changing the PowerShell execution policy using commands like <code class="code-block">Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass</code> to allow them to run.</p></li>
        <li><p class="list-item">Hinting at Detection: PowerShell scripts serve as automated assistants in the ScreenSharing process. They rapidly collect and pre-process data from numerous system artifacts, perform checks (like signature validation), and highlight potentially suspicious entries based on predefined logic, thereby accelerating the identification of evidence related to cheats or bypass attempts.</p></li>
    </ul>

    <h3 class="subsection-title">Spok's Tools</h3>
    <div class="note-box"><p class="body-paragraph">Note: For more up to date informations about new tools and features refer to Spok's Github page.</p></div>

    <h4 class="subsection-title">Replaceparser</h4>
    <p class="body-paragraph">
        Description: This is a simple parser designed by Spokwn primarily for testing its integration within his other tools. However, it can be used as a standalone utility for parsing file replacement actions.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Parses file replacement operations.</p></li>
        <li><p class="list-item">Can potentially be used as a library in other projects.</p></li>
    </ul>
    <div class="note-box"><p class="body-paragraph">Note: The provided release executable (<code class="file-extension">.exe</code>) might be outdated compared to the latest source code available.</p></div>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/Replaceparser</code>
    </p>

    <h4 class="subsection-title">JournalTrace</h4>
    <p class="body-paragraph">
        Description: A tool developed by Spokwn for parsing and viewing NTFS USN Journal entries through a graphical user interface. It's noted as being more advanced than Echo's Journal Tool because it provides specific event names, aiding in more detailed file analysis.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Parses the <code class="path-example">$UsnJrnl:$J</code> data stream from NTFS volumes.</p></li>
        <li><p class="list-item">Provides a user interface for exploring journal entries.</p></li>
        <li><p class="list-item">Displays event names (reasons for journal entries) like FileDelete, Rename, BasicInfoChange, etc.</p></li>
        <li><p class="list-item">Supports advanced filtering within columns:</p>
            <ul>
                <li><p class="list-item">Inclusions (&&): Find entries matching multiple conditions (e.g., <code class="code-block">name:rundll32&&.pf</code>).</p></li>
                <li><p class="list-item">Exclusions (!!): Exclude entries with specific values (e.g., <code class="code-block">name:.exe!!svchost</code>).</p></li>
                <li><p class="list-item">OR Conditions (||): Find entries matching one of several conditions (e.g., <code class="code-block">name:.exe||.dll</code>).</p></li>
                <li><p class="list-item">Multi-Column Filters (;): Filter across different columns simultaneously (e.g., <code class="code-block">name:.pf;reason:delete</code>). Column name prefix is optional if using operators.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Utilizes OpenByFileId wrapper to resolve file identifiers that might otherwise be unreadable.</p></li>
        <li><p class="list-item">Based on StCroixSkippers' C# wrapper for the UsnJournal Win32 API.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Hint: Essential for analyzing the history of file system changes, including creations, deletions, renames, and attribute modifications, helping to reconstruct activity on a drive.
    </p>
    <p class="body-paragraph">
        License: GNU General Public License v3.0.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/JournalTrace/releases</code>
    </p>

    <h4 class="subsection-title">pcasvc-executed</h4>
    <p class="body-paragraph">
        Description: A tool designed to parse or analyze execution data related to the Program Compatibility Assistant Service (PcaSvc).
    </p>
    <p class="body-paragraph">
        Usage Hint: Useful for investigating program execution traces logged by the PCA service.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/pcasvc-executed</code>
    </p>

    <h4 class="subsection-title">prefetch-parser</h4>
    <p class="body-paragraph">
        Description: A tool intended for parsing and analyzing Windows Prefetch files (<code class="file-extension">.pf</code>).
    </p>
    <p class="body-paragraph">
        Usage Hint: Aids in examining evidence of program execution stored within prefetch files.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/prefetch-parser</code>
    </p>

    <h4 class="subsection-title">ActivitiesCache-execution</h4>
    <p class="body-paragraph">
        Description: This tool is designed to parse or analyze the Windows Activities Cache database (<code class="path-example">ActivitiesCache.db</code>).
    </p>
    <p class="body-paragraph">
        Usage Hint: Helps in reviewing user activity history, including application usage, files opened, and websites visited, as logged by this artifact.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/ActivitiesCache-execution</code>
    </p>

    <h4 class="subsection-title">BAM-parser</h4>
    <p class="body-paragraph">
        Description: A semi-open-source parser for the Background Activity Moderator (BAM) registry keys. While the core parsing logic might be visible, most of the built-in generic detection rules are closed-source.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Parses BAM entries from the registry.</p></li>
        <li><p class="list-item">Includes numerous features deemed useful during ScreenShares (details likely in the project's README).</p></li>
        <li><p class="list-item">Incorporates several generic detection rules to flag potentially suspicious entries.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Notes:
    </p>
    <ul>
        <li><p class="list-item">Users are cautioned that flags from 1-3 generics hitting a single file should not lead to immediate conclusions; manual verification is recommended.</p></li>
        <li><p class="list-item">The developer (Spokwn) intends to refine generics to reduce potential false positives and provide better documentation in the future.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Hint: Useful for analyzing program execution evidence stored in the BAM keys, especially with its built-in checks for common suspicious patterns.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/BAM-parser</code>
    </p>

    <h4 class="subsection-title">process-parser</h4>
    <p class="body-paragraph">
        Description: A tool designed for parsing or analyzing information related to system processes.
    </p>
    <p class="body-paragraph">
        Usage Hint: Can be employed to examine details about running or historical process data.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/process-parser/releases/tag/v0.5.4</code>
    </p>

    <h4 class="subsection-title">Spokwn Powershell Scripts</h4>
    <p class="body-paragraph">
        This repository contains various PowerShell scripts developed by Spokwn.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/powershells</code>
    </p>

    <h4 class="subsection-title">Streams Script</h4>
    <p class="body-paragraph">
        Description: A PowerShell script designed to check for Alternate Data Streams (ADS), including the common Zone.Identifier stream, for files within a specified path.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Starts checking from the current directory where the script is run.</p></li>
        <li><p class="list-item">Prompts the user whether to search recursively into subdirectories.</p></li>
        <li><p class="list-item">Allows specifying the depth of recursion (number of levels) or searching all subdirectories ('all').</p></li>
        <li><p class="list-item">Displays a progress bar during the scan.</p></li>
        <li><p class="list-item">For each file/directory, it collects:</p>
            <ul>
                <li><p class="list-item">Full Path and Name.</p></li>
                <li><p class="list-item">MD5 Hash (for files only).</p></li>
                <li><p class="list-item">Owner (Name/SID).</p></li>
                <li><p class="list-item">Length (Size).</p></li>
                <li><p class="list-item">Last Access Time and Last Write Time.</p></li>
                <li><p class="list-item">File Attributes (Mode).</p></li>
                <li><p class="list-item">Contents of up to 5 data streams found (Stream1 to Stream5).</p></li>
                <li><p class="list-item">Contents of up to 4 lines from the Zone.Identifier stream (ZoneId1 to ZoneId4).</p></li>
            </ul>
        </li>
        <li><p class="list-item">Outputs the collected information into an interactive GridView window.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Hint: Primarily used for identifying files that have Alternate Data Streams, which can sometimes be used to hide data or track file origins (like downloads from the internet via Zone.Identifier).
    </p>

    <h4 class="subsection-title">ActivitiesCache Script</h4>
    <p class="body-paragraph">
        Description: A PowerShell script that automates the parsing of the Windows Activities Cache database. It downloads a dedicated parser executable (<code class="path-example">ActivitiesCacheParser.exe</code> from Spokwn's GitHub) to perform the analysis.
    </p>
    <p class="body-paragraph">
        Requirements: Must be run with Administrator privileges.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Downloads the necessary <code class="path-example">ActivitiesCacheParser.exe</code> to the temporary directory.</p></li>
        <li><p class="list-item">Invokes the parser to extract data into a temporary <code class="path-example">activities.txt</code> file.</p></li>
        <li><p class="list-item">Retrieves the oldest user logon time (for interactive logons, type 2 or 10) to use as a filter.</p></li>
        <li><p class="list-item">Parses the output file, filtering for activities that occurred after the oldest retrieved logon time.</p></li>
        <li><p class="list-item">For each relevant activity, it extracts and formats:</p>
            <ul>
                <li><p class="list-item">Application Path/Name.</p></li>
                <li><p class="list-item">Digital Signature status.</p></li>
                <li><p class="list-item">Generics detected by the parser (formatted with flags like [GenericName]).</p></li>
                <li><p class="list-item">StartTime and EndTime of the activity.</p></li>
            </ul>
        </li>
        <li><p class="list-item">Displays the formatted results directly in the PowerShell console.</p></li>
        <li><p class="list-item">Cleans up by removing the downloaded parser and the temporary output file upon completion.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Hint: Useful for quickly reviewing recent user application activity logged in the Activities Cache, filtered to the current user session.
    </p>

    <h4 class="subsection-title">Paths-Parser</h4>
    <p class="body-paragraph">
        Description: A comprehensive tool designed to analyze a list of file paths provided in specific <code class="file-extension">.txt</code> files (<code class="path-example">search results.txt</code>, <code class="path-example">paths.txt</code>, <code class="path-example">p.txt</code> located either in C:\ or the program's directory). It performs multiple checks on each valid path found.
    </p>
    <p class="body-paragraph">
        Features:
    </p>
    <ul>
        <li><p class="list-item">Path Parsing: Correctly handles and parses file paths, including those with the <code class="path-example">\\?\</code> prefix which might cause issues for simpler tools. Reads paths line by line from the specified input text files.</p></li>
        <li><p class="list-item">File Existence Check: Determines if the file at the given path currently exists or has been deleted ("Deleted" status).</p></li>
        <li><p class="list-item">Digital Signature Verification: Checks both Authenticode and Catalog signatures. Reports status as "Signed", "Not signed", or specific error states. Includes special detection for known signed cheats like Slinky and Vape.</p></li>
        <li><p class="list-item">Generic Detections: Applies a suite of 27 different "generic" checks (heuristics) designed to flag suspicious characteristics often found in malicious software or cheats. These are categorized (A for autoclickers, B for non-C# protection, C/D/E for C# protection, F for packed executables, G for injectors, Specific A/B for known cheats).</p></li>
        <li><p class="list-item">Replacement Check: Queries the USN Journal for each existing file path to identify potential file replacement patterns (specifically looks for sequences related to Explorer moves, copy command usage, or type command overwrites).</p></li>
        <li><p class="list-item">Output:</p>
            <ul>
                <li><p class="list-item">Displays analysis results (existence, signature, generics hits) for each path in the console.</p></li>
                <li><p class="list-item">Writes a summary of any detected file replacements to <code class="path-example">replaces.txt</code> in the program's directory.</p></li>
            </ul>
        </li>
    </ul>
    <p class="body-paragraph">
        Usage Notes & Caveats:
    </p>
    <ul>
        <li><p class="list-item">Generics A2 (DLL clickers) and the F-series (packed files) are noted as potentially causing occasional false positives but are kept active to maximize detection of actual cheats.</p></li>
        <li><p class="list-item">Users should carefully examine the timestamps associated with any detected replacements, as legitimate file updates can sometimes trigger these patterns.</p></li>
        <li><p class="list-item">Paths corresponding to deleted files might appear incomplete or "cut" due to how memory artifacts or the parsing process handles non-existent files.</p></li>
    </ul>
    <p class="body-paragraph">
        Usage Hint: A powerful tool for batch-analyzing file paths gathered from other tools (like System Informer string dumps) or logs, providing signature status, existence checks, heuristic-based suspicion levels, and detection of potential file replacements.
    </p>
    <p class="body-paragraph">
        Link: <code class="path-example">https://github.com/spokwn/PathsParser/releases</code>
    </p>


    <h3 class="subsection-title">Ban Evasion and Alt Account Detection</h3>
    <h4 class="subsection-title">Understanding Ban Evasion</h4>
    <p class="body-paragraph">
        Ban Evasion refers to the actions taken by a player to circumvent a ban imposed on them by a server or community. This often involves attempts to rejoin the game or community using methods that hide their original identity or bypass the ban mechanism itself. Common ban evasion tactics include:
    </p>
    <ul>
        <li><p class="list-item">Using Alternate Accounts: Creating or using different game accounts (often referred to as "alts") to play after the primary account has been banned.</p></li>
        <li><p class="list-item">Changing Hardware Identifiers (HWID): Attempting to modify or spoof hardware identifiers if the ban is linked to the player's machine (HWID ban) rather than just their account. This can involve using different computers or specialized software.</p></li>
        <li><p class="list-item">Using Virtual Machines (VMs): Running the game inside a virtual machine to obscure the host machine's hardware details or to isolate cheating tools from the primary operating system being screen shared.</p></li>
        <li><p class="list-item">IP Address Changes: Utilizing VPNs, proxies, or dynamic IP addresses to mask their network identity.</p></li>
    </ul>
    <p class="body-paragraph">
        ScreenSharing practices must often address the possibility of ban evasion, looking for evidence that links a currently investigated player to previously banned accounts or machines.
    </p>

    <h4 class="subsection-title">Identifying Alternate Accounts During ScreenShare</h4>
    <p class="body-paragraph">
        Finding evidence of alternate accounts is a crucial aspect of addressing ban evasion. While ScreenSharing, examiners look for artifacts that might link the current user session or machine to other identities associated with the player.
    </p>

    <h5 class="subsection-title">Username and Account Artifacts in Files:</h5>
    <ul>
        <li><p class="list-item">Players often leave traces of usernames across various files. Configuration files (e.g., <code class="file-extension">.json</code>, <code class="file-extension">.txt</code>), log files (including chat logs from game clients or launchers), and user directories can contain references to current and past usernames.</p></li>
        <li><p class="list-item">Specific game launchers (like Lunar Client, as mentioned in the context of Linux file structures) store account-related information in dedicated folders (e.g., <code class="path-example">/home/username/.lunarclient/</code>). Analyzing files like <code class="path-example">accounts.json</code> within these directories can reveal multiple accounts used on the machine.</p></li>
        <li><p class="list-item">Systematic searching through user directories (<code class="path-example">C:\Users\%username%</code>) and application data folders (AppData) for files containing known or suspected alternate usernames can yield results. Automated scripts are sometimes employed to search text-based files across user profiles for specific username patterns.</p></li>
    </ul>

    <h5 class="subsection-title">Registry Analysis:</h5>
    <ul>
        <li><p class="list-item">The Windows Registry stores vast amounts of configuration data, including user-specific settings. Each Windows user profile has its own registry hive (<code class="path-example">NTUSER.DAT</code>). Analyzing these hives can sometimes reveal information about different user profiles that have existed on the machine.</p></li>
        <li><p class="list-item">Certain registry keys associated with software installations, game launchers, or even Windows itself might contain account identifiers or usage history that could link different accounts used on the same system. Tools like Registry Explorer allow for in-depth examination of these hives, including potentially recovering deleted value data that might be relevant.</p></li>
    </ul>

    <h5 class="subsection-title">File System and Metadata:</h5>
    <ul>
        <li><p class="list-item">File system metadata, including file ownership information and directory structures within user profiles, can sometimes provide clues. Tools that parse the Master File Table ($MFT) might reveal file activities associated with different user accounts over time.</p></li>
        <li><p class="list-item">Directory paths themselves often include the Windows username (e.g., <code class="path-example">C:\Users\Username\...</code>). Finding files related to cheating or specific game configurations under different usernames within the same system is a strong indicator.</p></li>
    </ul>

    <h5 class="subsection-title">System Event Logs (EVTX):</h5>
    <ul>
        <li><p class="list-item">Windows Event Logs record numerous system activities, including user account management. Specific event IDs related to user account creation, deletion, enabling/disabling, or property changes can indicate attempts to manage multiple profiles, potentially for evasion purposes. Analyzing security or system logs might reveal a history of account manipulation.</p></li>
    </ul>

    <h5 class="subsection-title">Hardware Identification (HWID) Linking:</h5>
    <ul>
        <li><p class="list-item">Some ScreenSharing tools (like Echo, as described) and server-side systems implement HWID banning. This links a ban to the unique hardware signature of the player's computer.</p></li>
        <li><p class="list-item">During a ScreenShare, tools might collect HWID information and compare it against a database of known banned hardware. Finding a match suggests the player is attempting to evade a previous hardware-level ban, even if using a different game account. Examiners should be aware of how HWIDs are generated and collected by the tools they use.</p></li>
    </ul>

    <h4 class="subsection-title">Reviewing Ban Policies</h4>
    <p class="body-paragraph">
        It is essential for servers and communities to have clear, well-defined policies regarding ban evasion. These policies should specify:
    </p>
    <ul>
        <li><p class="list-item">What constitutes ban evasion (e.g., using alts, bypassing HWID bans).</p></li>
        <li><p class="list-item">The types of evidence considered sufficient to confirm ban evasion.</p></li>
        <li><p class="list-item">The consequences for players found to be evading bans.</p></li>
    </ul>
    <p class="body-paragraph">
        ScreenSharers must operate strictly within these established rules. A ban for evasion should only occur when the evidence meets the server's defined criteria. Relying on assumptions or insufficient proof can lead to incorrect bans.
    </p>

    <h4 class="subsection-title">Importance of Documentation and Evidence</h4>
    <p class="body-paragraph">
        Confirming ban evasion often requires linking disparate pieces of information found during the ScreenShare. Therefore, meticulous documentation is critical. ScreenSharers should:
    </p>
    <ul>
        <li><p class="list-item">Clearly record all usernames, account identifiers, file paths, registry keys, HWIDs, or other artifacts found that suggest the use of alternate accounts or evasion techniques.</p></li>
        <li><p class="list-item">Preserve evidence through screenshots, log exports, or recordings (as per server policy).</p></li>
        <li><p class="list-item">Correlate findings across different artifacts (e.g., linking a username found in a chat log to a registry entry or a file path).</p></li>
    </ul>
    <p class="body-paragraph">
        Robust documentation ensures that bans for evasion are well-supported, justifiable, and can withstand scrutiny during appeals. It also helps maintain consistency and fairness in enforcing server rules.
    </p>

</body>
</html>